<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dodge the Blocks — v13.2 (Themes + PIN music + robust buttons)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    :root { --green:#33ff66; --accent:#ff3dac; --scanline:rgba(255,255,255,0.06); }
    html, body { height: 100%; }
    body { margin: 0; background:#1a1a1a; display:flex; justify-content:center; align-items:center; color:#eee; font-family:"Courier New", monospace; }
    canvas { background:#0b0b0b; display:block; border:2px solid #2a2a2a; box-shadow:0 0 24px rgba(0,0,0,.6) inset; z-index:10; pointer-events:auto; touch-action:none; }
    .btn { font-family:inherit; font-weight:bold; padding:10px 18px; font-size:16px; cursor:pointer; margin:6px; border:2px solid var(--green); background:transparent; color:var(--green); text-shadow:0 0 6px rgba(51,255,102,.5); pointer-events:auto; transition:box-shadow .15s, background .15s, filter .15s; }
    .btn:hover { background: rgba(51,255,102,.18); box-shadow:0 0 8px rgba(51,255,102,.35); filter:brightness(1.05); }
    .btn-accent { border-color: var(--accent); color: var(--accent); text-shadow: 0 0 6px rgba(255,61,172,.6); }
    .btn-danger { border-color:#ff6b6b; color:#ff6b6b; text-shadow: 0 0 6px rgba(255,107,107,.6); }
    .btn.active, .btn[aria-pressed="true"] { background: rgba(51,255,102,.22); box-shadow:0 0 14px rgba(51,255,102,.6), inset 0 0 10px rgba(51,255,102,.25); filter:brightness(1.1); }
    #topBar { position:fixed; top:8px; left:8px; right:8px; display:flex; gap:12px; align-items:center; justify-content:space-between; z-index:60; font-size:14px; pointer-events:auto; }
    #userInfo { cursor:pointer; pointer-events:auto; }
    #homeOverlay { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; padding-top:56px;
      background: repeating-linear-gradient(0deg,transparent 0px, transparent 2px, var(--scanline) 3px, transparent 4px), radial-gradient(circle at 50% 20%, rgba(255,61,172,.12), transparent 40%), #050505;
      text-align:center; overflow:hidden; z-index:30; pointer-events:auto; }
    .retro-box { border:3px solid var(--green); box-shadow:0 0 24px rgba(51,255,102,.25), inset 0 0 12px rgba(51,255,102,.1); padding:22px 28px; background:#0c0c0c; }
    .corner { position:absolute; top:88px; right:16px; display:flex; gap:10px; pointer-events:auto; flex-wrap:wrap; max-width:80vw; justify-content:flex-end; z-index:35; }
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,.8); display:none; align-items:center; justify-content:center; z-index:80; pointer-events:auto; }
    .modal { width:720px; max-width:94vw; max-height:80vh; overflow:auto; background:#121212; border:2px solid var(--green); box-shadow:0 0 20px rgba(51,255,102,.3); border-radius:8px; padding:16px; }
    #errBanner { position:fixed; bottom:8px; left:8px; right:8px; background:#0e0e0e; color:#e3ffee; padding:8px 10px; border:1px solid #2dd562; border-radius:6px; font-size:12px; z-index:100; display:none; white-space:pre-wrap; }
    #restartBtn { display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); z-index:50; pointer-events:auto; }
    #cheatBar { position:fixed; bottom:60px; left:50%; transform:translateX(-50%); display:none; gap:8px; z-index:90; background:#0e0e0e; padding:8px 10px; border:1px solid #2a2a2a; border-radius:6px; }
    #cheatInput { padding:8px; font-size:14px; border:1px solid #3a3a3a; background:#0b0b0b; color:#fff; }
    #backHomeBtn { display:none; }
    .role-badge { color:#ff3dac; margin-left:4px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0; }
    input, select { background:#0b0b0b; color:#fff; border:1px solid #3a3a3a; padding:8px; }
    .section { border:1px solid #2a2a2a; padding:10px; border-radius:8px; margin:10px 0; }
    .section h4 { margin:0 0 8px 0; color:#9ad6ad; }
    .hint { font-size:12px; opacity:.8; }
    /* Themes list */
    #themesList { display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:12px; margin-top:8px; }
    .themeCard { border:1px solid #2a2a2a; border-radius:8px; padding:10px; cursor:pointer; }
    .themeCard.locked { opacity:.5; cursor:not-allowed; }
    .themeSwatch { height:60px; border-radius:6px; margin-bottom:8px; border:1px solid #333; }
    .themeCard.active { box-shadow:0 0 14px rgba(51,255,102,.6), inset 0 0 10px rgba(51,255,102,.25); }
  </style>
</head>
<body>
  <div id="topBar">
    <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
      <div id="userInfo" title="Tap while playing to open cheat bar">User: (not set)</div>
      <div id="highInfo">High: 0</div>
      <div id="netInfo"></div>
    </div>
    <div>
      <button id="backHomeBtn" class="btn" type="button">⮐ Back to Home</button>
      <span id="verBadge" style="font-size:11px;opacity:.7;">build: v13.2</span>
    </div>
  </div>

  <canvas id="gameCanvas" width="400" height="600" tabindex="0" aria-label="Game canvas"></canvas>

  <div id="homeOverlay">
    <div class="retro-box">
      <div id="title" style="font-size:48px;color:#33ff66;text-shadow:0 0 8px rgba(51,255,102,.7);">DODGE THE BLOCKS</div>
      <div id="subtitle" style="margin-bottom:18px;color:#9ad6ad;">made by Ethan Fehler</div>
      <button id="playBtn" class="btn btn-accent" type="button">▶ PLAY</button>
      <div class="pressStart" style="color:#ff3dac;">PRESS PLAY TO START</div>
    </div>
    <div class="corner">
      <button id="lbBtn" class="btn" type="button">LEADERBOARD</button>
      <button id="controlsBtn" class="btn" type="button">CONTROLS</button>
      <button id="setNameBtn" class="btn" type="button">SET USERNAME</button>
      <button id="themesBtn" class="btn" type="button">THEMES</button>
      <button id="ownerMenuBtn" class="btn" type="button" style="display:none;">OWNER MOD MENU</button>
    </div>
  </div>

  <div id="lbOverlay" class="overlay">
    <div class="modal">
      <button id="lbClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Global Leaderboard</h3>
      <div id="lbStatus" style="font-size:12px;opacity:.8;margin-bottom:6px;"></div>
      <table id="lbTable" style="width:100%;border-collapse:collapse;">
        <thead><tr><th>#</th><th>User</th><th>Best Score</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div id="nameOverlay" class="overlay">
    <div class="modal">
      <button id="nameCancel" class="btn" type="button" style="float:right;">Close</button>
      <h3>Set your username</h3>
      <input id="nameInput" placeholder="e.g., Ethan Fehler" maxlength="20" autocomplete="off">
      <div id="nameErr" style="color:#ff6b6b;min-height:1.2em;font-size:12px;"></div>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
        <button id="nameSave" class="btn btn-accent" type="button">Save</button>
      </div>
    </div>
  </div>

  <div id="controlsOverlay" class="overlay">
    <div class="modal">
      <button id="controlsClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Keyboard & Touch Controls</h3>
      <ul style="line-height:1.6; margin:0 0 8px 16px;">
        <li>← / → — Move left / right (desktop)</li>
        <li>Drag finger on the canvas — Move the square (mobile)</li>
        <li>P — Pause / resume (gameplay only)</li>
        <li>Enter — Confirm username</li>
        <li>Esc — Close the current dialog</li>
        <li>E — Toggle error banner</li>
      </ul>
    </div>
  </div>

  <div id="ownerOverlay" class="overlay">
    <div class="modal" id="ownerModal">
      <button id="ownerClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Owner Mod Menu</h3>
      <div class="hint">Owner-only controls. PIN is required for role changes.</div>

      <div class="section">
        <h4>Quick Toggles</h4>
        <div class="row" id="ownerToggles">
          <button class="btn" data-ot="godmode" aria-pressed="false">Godmode</button>
          <button class="btn" data-ot="rainbow" aria-pressed="false">Rainbow</button>
          <button class="btn" data-ot="ghost" aria-pressed="false">Ghost</button>
          <button class="btn" data-ot="reverse" aria-pressed="false">Reverse</button>
          <button class="btn" data-ot="speedy" aria-pressed="false">Speedy</button>
          <button class="btn" data-ot="bigplayer" aria-pressed="false">Big</button>
          <button class="btn" data-ot="tinyplayer" aria-pressed="false">Tiny</button>
          <button class="btn" id="otResetSize">Reset Size</button>
          <button class="btn" id="otDefaults">Set All to Default</button>
        </div>
      </div>

      <div class="section">
        <h4>Score Tools</h4>
        <div class="row" id="ownerScores">
          <button class="btn" id="setBestCurrent">Set Best = Current</button>
          <button class="btn" data-score="+1000">+1,000</button>
          <button class="btn" data-score="+10000">+10,000</button>
        </div>
        <div class="row">
          <input id="bestX" placeholder="Best = X" style="width:140px;">
          <button class="btn" id="setBestX">Apply</button>
        </div>
      </div>

      <div class="section">
        <h4>Speed & Spawn</h4>
        <div class="row">
          <label>Obstacle Speed</label>
          <input type="range" id="speedRange" min="0" max="40" value="4" step="1">
          <span id="speedLabel">4</span>
        </div>
        <div class="row">
          <label>Spawn Interval (ms)</label>
          <input type="range" id="spawnRange" min="50" max="1500" value="500" step="10">
          <span id="spawnLabel">500</span>
        </div>
        <div class="row" id="ownerSpeedBtns">
          <button class="btn" data-slow="1">Slowmo 1</button>
          <button class="btn" data-slow="2">Slowmo 2</button>
          <button class="btn" data-slow="4">Slowmo 4</button>
          <button class="btn" data-slow="8">Slowmo 8</button>
          <button class="btn" data-fast="50">Fastspawn 50</button>
          <button class="btn" data-fast="100">Fastspawn 100</button>
          <button class="btn" data-fast="200">Fastspawn 200</button>
        </div>
      </div>

      <div class="section">
        <h4>Set My Leaderboard Position</h4>
        <div class="row">
          <input id="desiredRank" type="number" min="1" step="1" placeholder="Rank (1 = top)" style="width:160px;">
          <button class="btn btn-accent" id="applyDesiredRank">Place Me</button>
        </div>
        <div class="hint">We read the current leaderboard and set your <b>best</b> to one point below the person above you.<br>
        Example: if you pick rank 3 and #2 has 12,345, your best becomes 12,344.</div>
        <div id="rankMsg" class="hint"></div>
      </div>

      <div class="section">
        <h4>Roles</h4>
        <div class="row">
          <input id="targetUser" placeholder="username" style="width:160px;">
          <select id="targetRole">
            <option value="player">player</option>
            <option value="mod">mod</option>
            <option value="owner">owner</option>
          </select>
          <input id="customRole" placeholder="custom role (optional)" style="width:180px;">
          <input id="ownerPIN" type="password" placeholder="Owner PIN">
          <button class="btn btn-accent" id="applyRole">Apply Role</button>
        </div>
        <div id="pinMsg" class="hint"></div>
        <div class="row">
          <input id="removeUser" placeholder="username" style="width:160px;">
          <input id="removePIN" type="password" placeholder="Owner PIN">
          <button class="btn btn-danger" id="removeRoleBtn">Remove Role</button>
        </div>
        <div id="removeMsg" class="hint"></div>
      </div>
    </div>
  </div>

  <div id="themesOverlay" class="overlay">
    <div class="modal">
      <button id="themesClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Unlockable Themes</h3>
      <div class="hint">Unlocks: Neon ≥ 500, Midnight ≥ 2000, Vaporwave ≥ 5000</div>
      <div id="themesList"></div>
    </div>
  </div>

  <div id="cheatBar"><input type="password" id="cheatInput" placeholder="Enter cheat code"><button id="applyCheat" class="btn" type="button">Apply</button></div>
  <button id="restartBtn" class="btn" type="button">Restart</button>

  <div id="errBanner"></div>
  <button id="errToggleFloat" class="btn" type="button" style="position:fixed; right:10px; bottom:10px; z-index:95; display:none;">Errors</button>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.43.1/dist/umd/supabase.js"></script>
  <script>
    const SUPABASE_URL = "https://staohtadlbeextexepdz.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN0YW9odGFkbGJlZXh0ZXhlcGR6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2MjAwNTIsImV4cCI6MjA3MDE5NjA1Mn0.OLQ3GIM4JV8oajuczviBsM-ueoJWV6ro65NIjpjYq0U";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  </script>

  <script>
  (function(){
    const OWNER_USERNAMES = new Set(["Ethan Fehler"]);
    const PROTECTED_NAMES = new Set(["Ethan Fehler"]);

    const errEl = document.getElementById('errBanner');
    function showErr(msg){ errEl.textContent = '⚠ ' + msg; errEl.style.display = 'block'; console.warn(msg); }
    function hideErr(){ errEl.style.display='none'; }
    window.onerror = function(m, s, l, c){ showErr('JS_ERROR: '+m+' @'+l+':'+c); };
    window.onunhandledrejection = function(ev){ showErr('PROMISE_REJECTION: '+(ev&&ev.reason&&ev.reason.message||ev&&ev.reason||'unknown')); };

    const $ = (id)=>document.getElementById(id);
    const userInfo=$('userInfo'), highInfo=$('highInfo'), netInfo=$('netInfo');
    const homeOverlay=$('homeOverlay'), controlsOverlay=$('controlsOverlay');
    const lbOverlay=$('lbOverlay'), nameOverlay=$('nameOverlay');
    const ownerOverlay=$('ownerOverlay'), ownerModal=$('ownerModal');
    const nameInput=$('nameInput'), nameErr=$('nameErr');
    const canvas=$('gameCanvas'), ctx=canvas.getContext('2d');
    const restartBtn=$('restartBtn'), backHomeBtn=$('backHomeBtn');
    const cheatBar=$('cheatBar'), cheatInput=$('cheatInput');
    const lbStatus=$('lbStatus');
    const ownerMenuBtn=$('ownerMenuBtn');
    const errToggleBtn=$('errToggleFloat');
    const themesOverlay = $('themesOverlay');
    const themesList = $('themesList');

    const loadScoresLocal=()=>{ try{return JSON.parse(localStorage.getItem('dodge_scores')||'{}');}catch{return{};} };
    const saveScoresLocal=o=> localStorage.setItem('dodge_scores', JSON.stringify(o));
    const getUser=()=> (localStorage.getItem('dodge_user')||'').trim();
    const setUser=u=> localStorage.setItem('dodge_user', u);

    // THEME SYSTEM
    const THEMES = {
      default:{ key:'default', name:'Default', req:0, bg:'#0b0b0b', player:'#39ff14', obstacle:'#ff3333', accent:'#33ff66' },
      neon:{ key:'neon', name:'Neon', req:500, bg:'#000000', player:'#39ff14', obstacle:'#ff007f', accent:'#39ff14' },
      midnight:{ key:'midnight', name:'Midnight', req:2000, bg:'#0a0f1f', player:'#8bd3ff', obstacle:'#ff6b6b', accent:'#8bd3ff' },
      vapor:{ key:'vapor', name:'Vaporwave', req:5000, bg:'#1b1026', player:'#ffd1dc', obstacle:'#8ef9f3', accent:'#ff77e9' }
    };
    function getBest(u){ const localBest=(loadScoresLocal()[u]||0); return localBest; } // UI will add remote on refresh
    let currentThemeKey = localStorage.getItem('dodge_theme') || 'default';
    function applyTheme(key){
      const t = THEMES[key] || THEMES.default;
      currentThemeKey = t.key;
      localStorage.setItem('dodge_theme', currentThemeKey);
      canvas.style.background = t.bg;
      // accent the UI a bit
      document.documentElement.style.setProperty('--green', t.accent || '#33ff66');
    }
    function renderThemes(){
      const u = getUser();
      const best = u ? getBest(u) : 0;
      const activeKey = currentThemeKey;
      themesList.innerHTML = '';
      Object.values(THEMES).forEach(t=>{
        const unlocked = best >= t.req;
        const card = document.createElement('div');
        card.className = 'themeCard' + (unlocked?'':' locked') + (t.key===activeKey?' active':'');
        card.dataset.act = unlocked ? 'themeSelect' : '';
        card.dataset.key = t.key;
        card.innerHTML = `
          <div class="themeSwatch" style="background:${t.bg};"></div>
          <div style="font-weight:bold">${t.name}</div>
          <div class="hint">Requires ${t.req}</div>
        `;
        themesList.appendChild(card);
      });
    }

    async function ensureProfile(u){
      if(!u) return { role:'player' };
      await supabase.from('profiles').upsert({ username:u }).select().maybeSingle();
      const { data } = await supabase.from('profiles').select('role').eq('username', u).maybeSingle();
      return { role: data?.role || 'player' };
    }
    function renderUserInfoBadge(u, role){
      const tag = role && role!=='player' ? ` <span class="role-badge">[${role}]</span>` : '';
      userInfo.innerHTML = 'User: ' + (u || '(not set)') + tag;
      const showOwner = role==='owner' || OWNER_USERNAMES.has(u);
      ownerMenuBtn.style.display = showOwner ? 'inline-block' : 'none';
    }
    async function refreshUserRoleUI(){
      const u=getUser();
      const { role } = await ensureProfile(u);
      renderUserInfoBadge(u, role);
      return role;
    }

    const player={x:180,y:550,width:40,height:40,speed:24,color:'#39ff14'};
    let obstacles=[], baseObstacleSpeed=4, obstacleSpeed=baseObstacleSpeed;
    let score=0, gameOver=false, baseSpawnInterval=500, spawnInterval=baseSpawnInterval;
    let spawnTimer=null, paused=true, speedIncreaseTimer=null, maxObstacleSpeed=12;
    let keys={left:false,right:false}; let screen='home', lbOpen=false;
    let currentRole='player';

    const cheats={ godmode:false, reverse:false, rainbow:false, ghost:false, speedy:false, bigplayer:false, tinyplayer:false, slowmo:null, slowtime:null, fastspawn:null };
    const ownerPresetCheats = { godmode:false, reverse:false, rainbow:false, ghost:false, speedy:false, bigplayer:false, tinyplayer:false, slowmo:null, slowtime:null, fastspawn:null };
    let cheatedThisRun=false;

    async function updateUserUI(){
      const u=getUser();
      if(!u){
        highInfo.textContent='High: 0';
        renderUserInfoBadge(u, 'player');
        netInfo.textContent = 'Online (no user)';
        currentRole='player';
        return;
      }
      const localBest = (loadScoresLocal()[u] || 0);
      const { data, error } = await supabase.from('scores').select('best').eq('username', u).maybeSingle();
      const remoteBest = error ? 0 : (data?.best || 0);
      highInfo.textContent='High: '+Math.max(localBest, remoteBest);
      netInfo.textContent = error ? 'Online (read error)' : 'Online';
      const { role } = await ensureProfile(u);
      currentRole = role || (OWNER_USERNAMES.has(u) ? 'owner' : 'player');
      renderUserInfoBadge(u, currentRole);
    }

    function openNameModal(prefill=''){ nameOverlay.style.display='flex'; nameInput.value=prefill; nameErr.textContent=''; setTimeout(()=>{ try{nameInput.focus();}catch{} },0); }
    function closeNameModal(){ nameOverlay.style.display='none'; }
    window.openNameModal = openNameModal; window.closeNameModal = closeNameModal;

    function saveBestLocal(u,s){ const scores=loadScoresLocal(); const prev=scores[u]||0; if(s>prev){ scores[u]=s; saveScoresLocal(scores); } }

    function onDeath(){
      if(gameOver) return;
      gameOver=true; clearInterval(spawnTimer); clearInterval(speedIncreaseTimer);
      const u=getUser(); if(u) saveBestLocal(u,score);
      restartBtn.style.display='inline-block';
      try{ submitScore(u, score); }catch{}
      showErr('E_DEAD: Hit a block — press Restart');
    }

    function curTheme(){ return THEMES[currentThemeKey] || THEMES.default; }
    function spawnObstacle(){
      if(!paused && !gameOver){
        const w=Math.random()*60+20, x=Math.random()*(canvas.width-w);
        obstacles.push({x, y: cheats.reverse? canvas.height+20 : -20, width:w, height:20, color: curTheme().obstacle});
      }
    }
    function startSpawning(){ clearInterval(spawnTimer); spawnTimer=setInterval(spawnObstacle, spawnInterval); }
    function startSpeedIncrease(){ clearInterval(speedIncreaseTimer); speedIncreaseTimer=setInterval(()=>{ if(!paused && !gameOver && baseObstacleSpeed<maxObstacleSpeed){ baseObstacleSpeed+=0.5; refreshEffectiveSpeeds(); } },10000); }
    function refreshEffectiveSpeeds(){
      if (cheats.slowmo != null) obstacleSpeed = Number(cheats.slowmo);
      else if (cheats.slowtime != null) obstacleSpeed = Number(cheats.slowtime);
      else obstacleSpeed = baseObstacleSpeed;
      let newSpawn = baseSpawnInterval;
      if (cheats.fastspawn != null) newSpawn = Number(cheats.fastspawn);
      else if (cheats.slowtime != null) newSpawn = 1500;
      if (newSpawn !== spawnInterval){ spawnInterval = newSpawn; startSpawning(); }
      updateOwnerMenuUI();
    }
    function update(){
      if(gameOver||paused||screen!=='playing') return;
      if(keys.left) player.x-=player.speed;
      if(keys.right) player.x+=player.speed;
      if(player.x<0) player.x=0;
      if(player.x+player.width>canvas.width) player.x=canvas.width-player.width;
      obstacles.forEach(o=> o.y += (cheats.reverse? -obstacleSpeed : obstacleSpeed));
      obstacles = obstacles.filter(o=> o.y<canvas.height+40 && o.y>-40);
      if(!cheats.godmode){
        for(const o of obstacles){
          if(player.x < o.x + o.width && player.x + player.width > o.x && player.y < o.y + o.height && player.y + player.height > o.y){
            onDeath(); break;
          }
        }
      }
      score += (cheats.reverse ? -1 : 1);
      if(cheats.rainbow){
        player.color = `hsl(${(Date.now()/10)%360},100%,50%)`;
        obstacles.forEach((o,i)=> o.color = `hsl(${(Date.now()/10 + i*20)%360},100%,50%)`);
      } else {
        player.color = cheats.ghost ? 'rgba(0,0,0,0)' : curTheme().player;
      }
    }
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle=player.color; ctx.fillRect(player.x,player.y,player.width,player.height);
      obstacles.forEach(o=>{ ctx.fillStyle=o.color; ctx.fillRect(o.x,o.y,o.width,o.height); });
      ctx.fillStyle='white'; ctx.font='20px Arial'; ctx.fillText('Score: '+score,10,30);
      const active = Object.entries(cheats).filter(([k,v]) => v === true || v === 0 || (typeof v === 'number')).map(([k,v]) => typeof v === 'number' ? `${k}(${v})` : k);
      if(active.length){
        ctx.font = '14px Arial'; ctx.textAlign = 'right'; ctx.textBaseline='top';
        active.forEach((label, i) => { ctx.fillStyle = label.startsWith('rainbow') ? `hsl(${(Date.now()/10)%360},100%,50%)` : '#ffffff'; ctx.fillText(label, canvas.width-8, 8+i*16); });
        ctx.textAlign='left'; ctx.textBaseline='alphabetic';
      }
      if(gameOver){ ctx.fillStyle='yellow'; ctx.font='40px Arial'; ctx.fillText('GAME OVER',80,canvas.height/2); }
      if(paused || screen!=='playing'){ ctx.fillStyle='orange'; ctx.font='30px Arial'; ctx.fillText('PAUSED',150,canvas.height/2); }
    }
    (function loop(){ update(); draw(); requestAnimationFrame(loop); })();

    function goHome(){ screen='home'; paused=true; gameOver=false; homeOverlay.style.display='flex'; backHomeBtn.style.display='none'; restartBtn.style.display='none'; if(errToggleBtn) errToggleBtn.style.display='none'; clearInterval(spawnTimer); clearInterval(speedIncreaseTimer); document.body.style.overflow='auto'; }
    function startPlaying(){
      if(!getUser()){ openNameModal(''); return; }
      screen='playing'; paused=false; gameOver=false; score=0; obstacles=[]; cheatedThisRun=false;
      applyTheme(currentThemeKey);
      // Apply presets on start
      for (const k in ownerPresetCheats) { cheats[k] = ownerPresetCheats[k]; }
      player.speed = cheats.speedy ? 35 : 24;
      if (cheats.bigplayer) { player.width=80; player.height=80; }
      else if (cheats.tinyplayer) { player.width=20; player.height=20; }
      else { player.width=40; player.height=40; }
      baseObstacleSpeed=4; obstacleSpeed=baseObstacleSpeed; baseSpawnInterval=500; spawnInterval=baseSpawnInterval;
      homeOverlay.style.display='none'; backHomeBtn.style.display='inline-block'; restartBtn.style.display='none'; if(errToggleBtn) errToggleBtn.style.display='inline-block';
      startSpawning(); startSpeedIncrease(); refreshEffectiveSpeeds();
      document.body.style.overflow='hidden'; canvas.focus();
      hideErr();
      updateOwnerMenuUI();
    }
    window.goHome=goHome; window.startPlaying=startPlaying;

    async function submitScore(u, s){
      if(!u){ updateUserUI(); return; }
      const scores = loadScoresLocal(); scores[u] = Math.max(scores[u]||0, s); saveScoresLocal(scores);
      const { data, error } = await supabase.from('scores').select('best').eq('username', u).maybeSingle();
      const remoteBest = error ? 0 : (data?.best || 0);
      const newBest = Math.max(remoteBest, s);
      if(newBest > remoteBest){
        await supabase.from('scores').upsert({ username: u, best: newBest }).select('best').maybeSingle();
      }
      await updateUserUI();
      if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
    }

    async function openLeaderboard(){
      const tbody = document.querySelector('#lbTable tbody');
      lbStatus.textContent = '';
      tbody.innerHTML = '<tr><td colspan="3" style="text-align:center;opacity:.8;">Loading…</td></tr>';

      const rowsRes = await supabase.from('scores').select('username,best').order('best', { ascending:false }).limit(50);
      if(rowsRes.error){ tbody.innerHTML = `<tr><td colspan="3" style="text-align:center;opacity:.8;">Load error: ${rowsRes.error.message}</td></tr>`; lbOverlay.style.display='flex'; lbOpen=true; return; }
      const rows = rowsRes.data||[];
      if(!rows.length){ tbody.innerHTML = '<tr><td colspan="3" style="text-align:center;opacity:.8;">No scores yet</td></tr>'; lbOverlay.style.display='flex'; lbOpen=true; return; }

      const names = rows.map(r=>r.username);
      const profsRes = await supabase.from('profiles').select('username,role').in('username', names);
      if(profsRes.error){ lbStatus.textContent = 'Profiles read limited: ' + profsRes.error.message; }
      const roleMap = new Map((profsRes.data||[]).map(p=>[p.username,p.role]));

      tbody.innerHTML = rows.map((r,i)=>{ 
        const role = roleMap.get(r.username);
        const badge = role && role!=='player' ? ` <span class="role-badge">[${role}]</span>` : '';
        return `<tr><td>${i+1}</td><td>${r.username}${badge}</td><td>${r.best}</td></tr>`;
      }).join('');

      lbOverlay.style.display='flex'; lbOpen=true;
    }
    function closeLeaderboard(){ lbOverlay.style.display='none'; lbOpen=false; }
    window.openLeaderboard=openLeaderboard; window.closeLeaderboard=closeLeaderboard;

    function showCheatBar(){ if(screen!=='playing') return; paused=true; cheatBar.style.display='flex'; setTimeout(()=>{ try{cheatInput.focus();}catch{} },0); }
    function closeCheatBar(){ cheatBar.style.display='none'; cheatInput.value=''; if(screen==='playing'&&!gameOver) paused=false; }
    async function applyCheatCode(){
      const raw=(cheatInput.value||'').trim().toLowerCase(); if(!raw){ closeCheatBar(); return; }
      if(raw.startsWith('disable ')){
        const d=raw.slice(8).trim();
        if(d==='godmode') ownerPresetCheats.godmode=cheats.godmode=false;
        if(d==='reverse') ownerPresetCheats.reverse=cheats.reverse=false;
        if(d==='rainbow') ownerPresetCheats.rainbow=cheats.rainbow=false;
        if(d==='ghost') ownerPresetCheats.ghost=cheats.ghost=false;
        if(d==='speedy'){ ownerPresetCheats.speedy=cheats.speedy=false; player.speed=24; }
        if(d==='bigplayer' || d==='tinyplayer'){ ownerPresetCheats.bigplayer=false; ownerPresetCheats.tinyplayer=false; cheats.bigplayer=false; cheats.tinyplayer=false; player.width=40; player.height=40; }
        if(d==='slowmo'){ ownerPresetCheats.slowmo=cheats.slowmo=null; }
        if(d==='slowtime'){ ownerPresetCheats.slowtime=cheats.slowtime=null; }
        if(d==='fastspawn'){ ownerPresetCheats.fastspawn=cheats.fastspawn=null; }
        refreshEffectiveSpeeds(); updateOwnerMenuUI(); closeCheatBar(); return;
      }
      const m=raw.match(/^([a-z]+)(\d+)?$/); if(!m){ closeCheatBar(); return; }
      const base=m[1], num=m[2]?parseInt(m[2],10):null;
      if(base in cheats && typeof cheats[base]==='boolean'){
        ownerPresetCheats[base]=cheats[base]=true;
        if(base==='speedy') player.speed=35;
        if(base==='bigplayer'){ ownerPresetCheats.tinyplayer=false; cheats.tinyplayer=false; player.width=80; player.height=80; }
        if(base==='tinyplayer'){ ownerPresetCheats.bigplayer=false; cheats.bigplayer=false; player.width=20; player.height=20; }
      } else if(base==='points'){
        score += (num!=null?num:1000);
      } else if(base==='slowmo'){
        ownerPresetCheats.slowmo = cheats.slowmo = (num!=null?num:1);
      } else if(base==='slowtime'){
        ownerPresetCheats.slowtime = cheats.slowtime = (num!=null?num:1);
      } else if(base==='fastspawn'){
        ownerPresetCheats.fastspawn = cheats.fastspawn = (num!=null?num:200);
      } else if(base==='clear'){
        obstacles = [];
      }
      refreshEffectiveSpeeds();
      updateOwnerMenuUI();
      closeCheatBar();
    }
    window.applyCheatCode=applyCheatCode;

    function updateOwnerMenuUI(){
      ownerModal.querySelectorAll('[data-ot]').forEach(btn=>{
        const key = btn.getAttribute('data-ot');
        const on = !!ownerPresetCheats[key];
        btn.classList.toggle('active', on);
        btn.setAttribute('aria-pressed', on ? 'true' : 'false');
      });
      const sr = $('speedRange'), sl = $('speedLabel'), spr=$('spawnRange'), spl=$('spawnLabel');
      if(sr){ sr.value = String(baseObstacleSpeed); if(sl) sl.textContent = String(baseObstacleSpeed); }
      if(spr){ spr.value = String(baseSpawnInterval); if(spl) spl.textContent = String(baseSpawnInterval); }
    }

    // ---- CENTRAL DELEGATED CLICK HANDLER ----
    const actions = {
      playBtn: ()=> startPlaying(),
      lbBtn: ()=> openLeaderboard(),
      lbClose: ()=> closeLeaderboard(),
      setNameBtn: ()=> openNameModal(getUser()),
      nameSave: async ()=>{
        const desired=(nameInput.value||'').trim(); 
        if(!desired){ nameErr.textContent='Please enter a username.'; return; }
        let needsPIN = PROTECTED_NAMES.has(desired);
        try{ 
          const prof = await supabase.from('profiles').select('role').eq('username', desired).maybeSingle();
          if(prof.data && prof.data.role==='owner') needsPIN = true;
        }catch(e){ /* ignore */ }
        if(needsPIN){ 
          const pin = window.prompt('Owner PIN required to use this name:');
          if(!pin) return;
          try{ 
            const { data, error } = await supabase.rpc('verify_owner_pin', { pin });
            if(error || !data){ nameErr.textContent='Wrong PIN.'; return; }
          }catch(e){ nameErr.textContent='PIN check failed.'; return; }
        }
        setUser(desired);
        await supabase.from('profiles').upsert({ username: desired });
        closeNameModal(); 
        await refreshUserRoleUI(); 
        updateUserUI(); 
        const b=$('setNameBtn'); if(b) b.textContent='EDIT USERNAME';
      },
      nameCancel: ()=> closeNameModal(),
      controlsBtn: ()=> { controlsOverlay.style.display='flex'; },
      controlsClose: ()=> { controlsOverlay.style.display='none'; },
      restartBtn: ()=> { if(screen==='playing') startPlaying(); },
      backHomeBtn: ()=> goHome(),
      applyCheat: ()=> applyCheatCode(),
      ownerMenuBtn: ()=> { ownerOverlay.style.display='flex'; updateOwnerMenuUI(); },
      ownerClose: ()=> { ownerOverlay.style.display='none'; },
      applyRole: async ()=>{
        const target=($('targetUser').value||'').trim(); 
        const dropdown=($('targetRole').value||'player'); 
        const custom=($('customRole').value||'').trim();
        const role = custom || dropdown;
        const pin=($('ownerPIN').value||'').trim(); 
        if(!target||!pin){ $('pinMsg').textContent='Enter username and PIN.'; return; } 
        const { data, error } = await supabase.rpc('grant_role', { target_username: target, new_role: role, pin }); 
        $('pinMsg').textContent = error ? ('Error: '+error.message) : ('Applied! ' + target + ' → ' + role); 
        await refreshUserRoleUI();
      },
      removeRoleBtn: async ()=>{
        const target=($('removeUser').value||'').trim();
        const pin=($('removePIN').value||'').trim();
        if(!target||!pin){ $('removeMsg').textContent='Enter username and PIN.'; return; }
        const { data, error } = await supabase.rpc('grant_role', { target_username: target, new_role: 'player', pin });
        $('removeMsg').textContent = error ? ('Error: '+error.message) : ('Removed: ' + target + ' is now player');
        await refreshUserRoleUI();
      },
      errToggleFloat: ()=> { errEl.style.display = (errEl.style.display==='block' ? 'none' : 'block'); },
      applyDesiredRank: async ()=>{
        const rankStr = (document.getElementById('desiredRank').value||'').trim();
        const desiredRank = parseInt(rankStr,10);
        const u = getUser();
        if(!u || !Number.isFinite(desiredRank) || desiredRank<1){ document.getElementById('rankMsg').textContent='Enter a valid rank (1 or higher).'; return; }
        const { data: rows, error } = await supabase.from('scores').select('username,best').order('best',{ascending:false}).limit(200);
        if(error){ document.getElementById('rankMsg').textContent = 'Read error: '+error.message; return; }
        if(!rows || rows.length===0){
          await supabase.from('scores').upsert({ username:u, best: 1 }).select('best');
          await updateUserUI(); if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
          document.getElementById('rankMsg').textContent='Placed at rank 1 with 1 point.';
          return;
        }
        if(desiredRank===1){
          const topBest = rows[0].best || 0;
          const newBest = topBest + 1;
          await supabase.from('scores').upsert({ username: u, best: newBest }).select('best');
          await updateUserUI(); if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
          document.getElementById('rankMsg').textContent='Placed at rank 1 with '+newBest+'.';
          return;
        }
        if(desiredRank > rows.length){
          const lastBest = rows[rows.length-1].best || 0;
          const newBest = Math.max(0, lastBest - 1);
          await supabase.from('scores').upsert({ username:u, best: newBest }).select('best');
          await updateUserUI(); if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
          document.getElementById('rankMsg').textContent='Placed near bottom with '+newBest+'.';
          return;
        }
        const aboveIndex = desiredRank - 2;
        const aboveBest = rows[aboveIndex]?.best ?? 0;
        let newBest = Math.max(0, aboveBest - 1);
        while(newBest>0 && rows.some(r => r.best === newBest && r.username !== u)){ newBest -= 1; }
        await supabase.from('scores').upsert({ username:u, best: newBest }).select('best');
        await updateUserUI(); if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
        document.getElementById('rankMsg').textContent='Placed at ~rank '+desiredRank+' with '+newBest+'.';
      },
      setBestCurrent: async ()=>{
        const u=getUser(); if(!u) return;
        await supabase.from('scores').upsert({ username:u, best: score });
        await updateUserUI(); if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
      },
      setBestX: async ()=>{
        const u=getUser(); if(!u) return;
        const x = parseInt((document.getElementById('bestX').value||'').trim(),10);
        if(Number.isFinite(x)){
          await supabase.from('scores').upsert({ username:u, best: x });
          await updateUserUI(); if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
        }
      },
      themesBtn: ()=>{ renderThemes(); themesOverlay.style.display='flex'; },
      themesClose: ()=>{ themesOverlay.style.display='none'; },
      themeSelect: (btn)=>{ const key = btn.dataset.key; if(!key) return; applyTheme(key); renderThemes(); }
    };
    document.addEventListener('click', (e)=>{
      const btn = e.target.closest('button, .themeCard');
      if(!btn) return;
      const act = btn.dataset.act || btn.id;
      if(!act) return;
      if(actions[act]){
        try{
          e.preventDefault(); e.stopPropagation();
          actions[act](btn);
        }catch(err){ showErr('BTN_ERR: '+(err.message||err)); }
      }
    }, {capture:true});

    // Owner modal toggles / score / speed buttons remain via delegated click inside ownerModal
    ownerModal.addEventListener('click', (e)=>{
      const t = e.target.closest('button');
      if(!t) return;
      if(t.hasAttribute('data-ot')){
        e.preventDefault(); e.stopPropagation();
        const key = t.getAttribute('data-ot');
        if(!(key in ownerPresetCheats)) return;
        const newVal = !ownerPresetCheats[key];
        if(key==='bigplayer' && newVal){ ownerPresetCheats.bigplayer=true; ownerPresetCheats.tinyplayer=false; }
        else if(key==='tinyplayer' && newVal){ ownerPresetCheats.tinyplayer=true; ownerPresetCheats.bigplayer=false; }
        else { ownerPresetCheats[key] = newVal; }
        if(screen==='playing'){
          cheats[key] = (key==='bigplayer'||key==='tinyplayer') ? ownerPresetCheats[key] : newVal;
          if(key==='bigplayer' && newVal){ cheats.tinyplayer=false; player.width=80; player.height=80; }
          if(key==='tinyplayer' && newVal){ cheats.bigplayer=false; player.width=20; player.height=20; }
          if((key==='bigplayer' || key==='tinyplayer') && !newVal){ player.width=40; player.height=40; }
          if(key==='speedy'){ player.speed = newVal ? 35 : 24; }
          refreshEffectiveSpeeds();
        }
        updateOwnerMenuUI();
        return;
      }
      if(t.hasAttribute('data-score')){
        e.preventDefault(); e.stopPropagation();
        const v = parseInt(t.getAttribute('data-score').replace('+',''),10);
        if(Number.isFinite(v)) score += v;
        return;
      }
      if(t.hasAttribute('data-slow')){
        e.preventDefault(); e.stopPropagation();
        ownerPresetCheats.slowmo = parseInt(t.getAttribute('data-slow'),10); ownerPresetCheats.slowtime=null; cheats.slowmo = ownerPresetCheats.slowmo; cheats.slowtime=null; refreshEffectiveSpeeds(); return;
      }
      if(t.hasAttribute('data-fast')){
        e.preventDefault(); e.stopPropagation();
        ownerPresetCheats.fastspawn = parseInt(t.getAttribute('data-fast'),10); cheats.fastspawn = ownerPresetCheats.fastspawn; refreshEffectiveSpeeds(); return;
      }
    }, {passive:false});

    // Sliders
    const speedRange=$('speedRange'), spawnRange=$('spawnRange');
    if(speedRange) speedRange.addEventListener('input', (e)=>{ $('speedLabel').textContent=e.target.value; baseObstacleSpeed=parseInt(e.target.value,10); cheats.slowmo=null; ownerPresetCheats.slowmo=null; refreshEffectiveSpeeds(); }, {passive:true});
    if(spawnRange) spawnRange.addEventListener('input', (e)=>{ $('spawnLabel').textContent=e.target.value; baseSpawnInterval=parseInt(e.target.value,10); cheats.fastspawn=null; ownerPresetCheats.fastspawn=null; refreshEffectiveSpeeds(); }, {passive:true});

    // User info click & mobile drag, keys
    userInfo.addEventListener('click', function(){ if(screen==='playing'){ showCheatBar(); } else { openNameModal(getUser()); } }, {passive:true});

    let dragging=false;
    const canvasX = (clientX)=>{ const r=canvas.getBoundingClientRect(); const x=(clientX-r.left)*(canvas.width/r.width); return Math.max(0, Math.min(canvas.width-player.width, x-player.width/2)); };
    canvas.addEventListener('mousedown', e=>{ if(screen!=='playing') return; e.preventDefault(); dragging=true; player.x=canvasX(e.clientX); }, {passive:false});
    window.addEventListener('mousemove', e=>{ if(dragging && screen==='playing'){ e.preventDefault(); player.x=canvasX(e.clientX); } }, {passive:false});
    window.addEventListener('mouseup', ()=>{ dragging=false; }, {passive:true});
    canvas.addEventListener('touchstart', e=>{ if(screen!=='playing') return; if(e.touches[0]){ e.preventDefault(); dragging=true; player.x=canvasX(e.touches[0].clientX);} }, {passive:false});
    canvas.addEventListener('touchmove', e=>{ if(dragging && e.touches[0]){ e.preventDefault(); player.x=canvasX(e.touches[0].clientX);} }, {passive:false});
    canvas.addEventListener('touchend', e=>{ e.preventDefault(); dragging=false; }, {passive:false});
    canvas.addEventListener('touchcancel', e=>{ e.preventDefault(); dragging=false; }, {passive:false});

    function isTypingTarget(t){ return t && (t.tagName==='INPUT' || t.tagName==='TEXTAREA' || t.isContentEditable); }
    window.addEventListener('keydown', (e)=>{
      if((e.key==='e'||e.key==='E') && !isTypingTarget(e.target)){ e.preventDefault(); errEl.style.display = (errEl.style.display==='block' ? 'none' : 'block'); return; }
      const typing = isTypingTarget(e.target) || (cheatBar.style.display==='flex');
      if(screen==='playing' && !lbOpen && !typing){
        if(e.key==='ArrowLeft' || e.key==='Left' || e.keyCode===37){ e.preventDefault(); keys.left=true; }
        if(e.key==='ArrowRight' || e.key==='Right' || e.keyCode===39){ e.preventDefault(); keys.right=true; }
        if(e.key==='p' || e.key==='P' || e.keyCode===80){ e.preventDefault(); paused=!paused; }
        if(e.key==='Shift'){ e.preventDefault(); showCheatBar(); }
      }
      if(cheatBar.style.display==='flex'){
        if(e.key==='Enter'){ e.preventDefault(); applyCheatCode(); }
        if(e.key==='Escape'){ e.preventDefault(); closeCheatBar(); }
      }
      if(nameOverlay.style.display==='flex'){
        if(e.key==='Enter'){ e.preventDefault(); document.getElementById('nameSave').click(); }
        if(e.key==='Escape'){ e.preventDefault(); closeNameModal(); }
      }
    }, {passive:false});
    window.addEventListener('keyup', (e)=>{ if(screen==='playing' && !lbOpen && !(isTypingTarget(e.target))){ if(e.key==='ArrowLeft' || e.key==='Left' || e.keyCode===37){ e.preventDefault(); keys.left=false; } if(e.key==='ArrowRight' || e.key==='Right' || e.keyCode===39){ e.preventDefault(); keys.right=false; } } }, {passive:false});

    // ---- Elevator music while typing PIN ----
    let pinCtx=null, pinOsc=null, pinGain=null, pinTimer=null, pinSeqIndex=0;
    const pinScale=[261.63, 311.13, 349.23, 392.00, 466.16]; // C Eb F G Bb
    function startPinMusic(){
      try{
        if(pinCtx) return;
        pinCtx = new (window.AudioContext||window.webkitAudioContext)();
        pinGain = pinCtx.createGain(); pinGain.gain.value = 0.025; pinGain.connect(pinCtx.destination);
        pinTimer = setInterval(()=>{
          if(!pinCtx) return;
          const freq = pinScale[pinSeqIndex++ % pinScale.length];
          if(pinOsc) { try{ pinOsc.stop(); }catch{} }
          pinOsc = pinCtx.createOscillator();
          pinOsc.type = 'triangle';
          pinOsc.frequency.value = freq;
          pinOsc.connect(pinGain);
          pinOsc.start();
          pinOsc.stop(pinCtx.currentTime + 0.6);
        }, 700);
      }catch(e){ /* ignore */ }
    }
    function stopPinMusic(){
      try{
        if(pinTimer) clearInterval(pinTimer); pinTimer=null;
        if(pinOsc){ try{ pinOsc.stop(); }catch{} pinOsc=null; }
        if(pinCtx){ try{ pinCtx.close(); }catch{} pinCtx=null; }
      }catch(e){ /* ignore */ }
    }
    ownerOverlay.addEventListener('focusin', (e)=>{
      if(e.target && e.target.id==='ownerPIN'){ startPinMusic(); }
    });
    ownerOverlay.addEventListener('focusout', (e)=>{
      if(e.target && e.target.id==='ownerPIN'){ stopPinMusic(); }
    });

    (async function init(){
      applyTheme(currentThemeKey);
      const b=document.getElementById('setNameBtn'); if(b) b.textContent=getUser()?'EDIT USERNAME':'SET USERNAME';
      try{ await updateUserUI(); }catch(e){ showErr('INIT_ERR: '+(e.message||e)); }
    })();
  })();
  </script>
</body>
</html>
