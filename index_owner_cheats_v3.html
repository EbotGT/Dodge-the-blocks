<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dodge the Blocks — Owner Cheats v3</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    :root { --green:#33ff66; --accent:#ff3dac; --scanline:rgba(255,255,255,0.06); }
    html, body { height: 100%; }
    body { margin: 0; background:#1a1a1a; display:flex; justify-content:center; align-items:center; color:#eee; font-family:"Courier New", monospace; }
    canvas { background:#0b0b0b; display:block; border:2px solid #2a2a2a; box-shadow:0 0 24px rgba(0,0,0,.6) inset; z-index:1; pointer-events:auto; touch-action:none; }
    .btn { font-family:inherit; font-weight:bold; padding:12px 22px; font-size:18px; cursor:pointer; margin:6px; border:2px solid var(--green); background:transparent; color:var(--green); text-shadow:0 0 6px rgba(51,255,102,.5); }
    .btn:hover { background: rgba(51,255,102,.1); }
    .btn-accent { border-color: var(--accent); color: var(--accent); text-shadow: 0 0 6px rgba(255,61,172,.6); }
    #topBar { position:fixed; top:8px; left:8px; right:8px; display:flex; gap:8px; align-items:center; justify-content:space-between; z-index:40; font-size:14px; }
    #userInfo { cursor:pointer; }
    #homeOverlay { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: repeating-linear-gradient(0deg,transparent 0px, transparent 2px, var(--scanline) 3px, transparent 4px), radial-gradient(circle at 50% 20%, rgba(255,61,172,.12), transparent 40%), #050505;
      text-align:center; overflow:hidden; z-index:30; }
    .retro-box { border:3px solid var(--green); box-shadow:0 0 24px rgba(51,255,102,.25), inset 0 0 12px rgba(51,255,102,.1); padding:22px 28px; background:#0c0c0c; }
    .corner { position:absolute; top:16px; right:16px; display:flex; gap:8px; }
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,.8); display:none; align-items:center; justify-content:center; z-index:70; }
    .modal { width:560px; max-width:92vw; max-height:75vh; overflow:auto; background:#121212; border:2px solid var(--green); box-shadow:0 0 20px rgba(51,255,102,.3); border-radius:8px; padding:16px; }
    #errBanner { position:fixed; bottom:8px; left:8px; right:8px; background:#0e1010; color:#e3ffee; padding:8px 10px; border:1px solid #2dd562; border-radius:6px; font-size:12px; z-index:100; display:none; white-space:pre-wrap; }
    #restartBtn { display:none; position:fixed; top:8px; left:50%; transform:translateX(-50%); z-index:50; }
    #cheatBar { position:fixed; bottom:60px; left:50%; transform:translateX(-50%); display:none; gap:8px; z-index:90; background:#0e0e0e; padding:8px 10px; border:1px solid #2a2a2a; border-radius:6px; }
    #cheatInput { padding:8px; font-size:14px; border:1px solid #3a3a3a; background:#0b0b0b; color:#fff; }
    /* Diagnostics HUD */
    #diagHUD { position:fixed; top:8px; right:8px; z-index:120; background:#0b0b0b; border:1px solid #2a2a2a; padding:8px 10px; border-radius:8px; width:280px; font-size:12px; }
    #diagHUD.hidden { display:none !important; }
    #diagHUD h4 { margin:0 0 6px 0; color:#9ad6ad; }
    .flag { display:flex; justify-content:space-between; margin:2px 0; }
    .ok { color:#33ff66; } .bad { color:#ff6b6b; } .warn { color:#ffd166; }
    #diagLog { max-height:200px; overflow:auto; background:#0e0e0e; border:1px solid #222; padding:6px; margin-top:6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre-wrap; }
  </style>
</head>
<body>
  <div id="topBar">
    <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
      <div id="userInfo" title="Tap while playing to open cheat bar">User: (not set)</div>
      <div id="highInfo">High: 0</div>
      <div id="netInfo"></div>
    </div>
    <div>
      <button id="backHomeBtn" class="btn" type="button" style="display:none;">⮐ Back to Home</button>
      <span id="verBadge" style="font-size:11px;opacity:.7;">build: owner-cheats-v3</span>
    </div>
  </div>

  <!-- Diagnostics HUD (force hidden on load) -->
  <div id="diagHUD" class="hidden" style="display:none;">
    <h4>Diagnostics (press Space)</h4>
    <div class="flag"><span>Buttons wired</span><span id="f-btns" class="bad">no</span></div>
    <div class="flag"><span>Keyboard active</span><span id="f-keys" class="bad">no</span></div>
    <div class="flag"><span>Cheat bar works</span><span id="f-cheat" class="bad">no</span></div>
    <div class="flag"><span>Supabase client</span><span id="f-sb" class="warn">n/a</span></div>
    <div class="flag"><span>Owner detected</span><span id="f-owner" class="warn">n/a</span></div>
    <div id="diagLog"></div>
  </div>

  <canvas id="gameCanvas" width="400" height="600" tabindex="0" aria-label="Game canvas"></canvas>

  <div id="homeOverlay">
    <div class="retro-box">
      <div id="title" style="font-size:48px;color:#33ff66;text-shadow:0 0 8px rgba(51,255,102,.7);">DODGE THE BLOCKS</div>
      <div id="subtitle" style="margin-bottom:18px;color:#9ad6ad;">made by Ethan Fehler</div>
      <button id="playBtn" class="btn btn-accent" type="button">▶ PLAY</button>
      <div class="pressStart" style="color:#ff3dac;">PRESS PLAY TO START</div>
    </div>
    <div class="corner">
      <button id="lbBtn" class="btn" type="button">LEADERBOARD</button>
      <button id="controlsBtn" class="btn" type="button">CONTROLS</button>
      <button id="setNameBtn" class="btn" type="button">SET USERNAME</button>
    </div>
  </div>

  <!-- Cheat bar -->
  <div id="cheatBar"><input type="password" id="cheatInput" placeholder="Enter cheat code"><button id="applyCheat" class="btn" type="button">Apply</button></div>
  <button id="restartBtn" class="btn" type="button">Restart</button>

  <!-- Leaderboard -->
  <div id="lbOverlay" class="overlay">
    <div class="modal">
      <button id="lbClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Global Leaderboard</h3>
      <table id="lbTable" style="width:100%;border-collapse:collapse;">
        <thead><tr><th>#</th><th>User</th><th>Best Score</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Name modal -->
  <div id="nameOverlay" class="overlay">
    <div class="modal">
      <button id="nameCancel" class="btn" type="button" style="float:right;">Close</button>
      <h3>Set your username</h3>
      <input id="nameInput" placeholder="e.g., PlayerOne" maxlength="20" autocomplete="off">
      <div id="nameErr" style="color:#ff6b6b;min-height:1.2em;font-size:12px;"></div>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
        <button id="nameSave" class="btn btn-accent" type="button">Save</button>
      </div>
    </div>
  </div>

  <!-- Controls modal -->
  <div id="controlsOverlay" class="overlay">
    <div class="modal">
      <button id="controlsClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Keyboard & Touch Controls</h3>
      <ul style="line-height:1.6; margin:0 0 8px 16px;">
        <li>← / → — Move left / right (desktop)</li>
        <li>Drag finger on the canvas — Move the square (mobile)</li>
        <li>P — Pause / resume (gameplay only)</li>
        <li>Enter — Confirm username</li>
        <li>Esc — Close the current dialog</li>
        <li>E — Toggle error banner</li>
        <li>Space — Toggle diagnostics HUD (unless typing)</li>
      </ul>
    </div>
  </div>

  <div id="errBanner"></div>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.43.1/+esm';

    // ====== CONFIG ======
    const SUPABASE_URL = "https://staohtadlbeextexepdz.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN0YW9odGFkbGJlZXh0ZXhlcGR6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2MjAwNTIsImV4cCI6MjA3MDE5NjA1Mn0.OLQ3GIM4JV8oajuczviBsM-ueoJWV6ro65NIjpjYq0U";
    const supabase = (SUPABASE_URL && SUPABASE_ANON_KEY) ? createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;
    const OWNER_USERNAMES = new Set(["Ethan Fehler"]);
    const ALLOW_CHEATED_SCORES = true;

    // ====== DOM ======
    const $ = id => document.getElementById(id);
    const userInfo=$('userInfo'), highInfo=$('highInfo'), netInfo=$('netInfo');
    const homeOverlay=$('homeOverlay'), controlsOverlay=$('controlsOverlay');
    const lbOverlay=$('lbOverlay'), nameOverlay=$('nameOverlay');
    const nameInput=$('nameInput'), nameErr=$('nameErr');
    const canvas=$('gameCanvas'), ctx=canvas.getContext('2d');
    const restartBtn=$('restartBtn'), backHomeBtn=$('backHomeBtn');
    const cheatBar=$('cheatBar'), cheatInput=$('cheatInput'), applyCheat=$('applyCheat');
    const lbTableBody = document.querySelector('#lbTable tbody');
    const diagHUD = $('diagHUD');

    // ====== DIAGNOSTICS ======
    const diag = {
      logEl: $('diagLog'),
      f: { btns: $('f-btns'), keys: $('f-keys'), cheat: $('f-cheat'), sb: $('f-sb'), owner: $('f-owner') },
      log(msg){ if(this.logEl){ this.logEl.textContent += (this.logEl.textContent? '\n' : '') + msg; this.logEl.scrollTop = this.logEl.scrollHeight; } },
      ok(el){ if(el){ el.className='ok'; el.textContent='ok'; } },
      warn(el,t='n/a'){ if(el){ el.className='warn'; el.textContent=t; } },
      toggle(){ diagHUD.classList.toggle('hidden'); diagHUD.style.display = diagHUD.classList.contains('hidden') ? 'none' : 'block'; this.log('HUD '+(diagHUD.classList.contains('hidden')?'hidden':'shown')); }
    };
    diag.warn(diag.f.sb, supabase ? 'ok' : 'n/a');

    // ====== UTIL & ERR ======
    const errEl=$('errBanner'); let errVisible=false, errText="";
    const isTypingTarget = t => t && (t.tagName==='INPUT' || t.tagName==='TEXTAREA' || t.isContentEditable);
    const showErr = (msg)=>{ errText='⚠ '+msg; errVisible=true; errEl.textContent=errText; errEl.style.display='block'; };
    window.onerror = (m, s, l, c)=> showErr(`JS_ERROR: ${m} @${l}:${c}`);
    window.onunhandledrejection = (ev)=> showErr(`PROMISE_REJECTION: ${ev?.reason?.message || ev?.reason || ev}`);

    // ====== STORAGE ======
    const loadScoresLocal=()=>{ try{return JSON.parse(localStorage.getItem('dodge_scores')||'{}');}catch{return{};} };
    const saveScoresLocal=o=> localStorage.setItem('dodge_scores', JSON.stringify(o));
    const getUser=()=> (localStorage.getItem('dodge_user')||'').trim();
    const setUser=u=> localStorage.setItem('dodge_user', u);
    const updateSetNameButton=()=>{ const b=$('setNameBtn'); if(b) b.textContent=getUser()?'EDIT USERNAME':'SET USERNAME'; };

    function renderUserInfo(u){ userInfo.innerHTML='User: '+(u || '(not set)'); }

    // ====== NAME MODAL ======
    function openNameModal(prefill=""){
      nameOverlay.style.display='flex'; nameInput.value=prefill; nameErr.textContent='';
      setTimeout(()=>{ try{nameInput.focus();}catch{} },0);
    }
    function closeNameModal(){ nameOverlay.style.display='none'; }
    async function saveNameFromModal(){
      const u=(nameInput.value||'').trim();
      if(!u){ nameErr.textContent='Please enter a username.'; return; }
      setUser(u); updateSetNameButton(); renderUserInfo(u); closeNameModal(); await updateUserUI();
    }

    // ====== ROLES / LEADERBOARD HELPERS ======
    let currentRole = null;
    function isOwner() {
      const u=getUser();
      return (currentRole==='owner') || (u && OWNER_USERNAMES.has(u));
    }
    function roleBadge(role, username){
      if(role) return `<span class="role ${role}" style="font-size:11px;margin-left:6px;text-transform:uppercase;">${role}</span>`;
      if(OWNER_USERNAMES.has(username)) return `<span class="role owner" style="font-size:11px;margin-left:6px;text-transform:uppercase;color:gold;border:1px solid #a88e00;padding:1px 6px;border-radius:10px;">owner</span>`;
      return '';
    }
    async function fetchRole(username){
      if(!supabase||!username) return null;
      const { data, error } = await supabase.from('profiles').select('role').eq('username', username).maybeSingle();
      return error ? null : (data?.role||null);
    }
    async function fetchBest(username){
      if(!supabase||!username) return null;
      const { data, error } = await supabase.from('scores').select('best').eq('username', username).maybeSingle();
      return error ? null : (data?.best ?? 0);
    }

    async function updateUserUI(localOnly=false){
      const u=getUser();
      const localScores=loadScoresLocal();
      const localBest=u && localScores[u] ? localScores[u] : 0;
      if(localOnly||!supabase){
        currentRole = OWNER_USERNAMES.has(u)?'owner':null;
        userInfo.innerHTML='User: '+(u||'(not set)')+roleBadge(currentRole,u);
        highInfo.textContent='High: '+localBest;
        netInfo.textContent=supabase?'':'Offline leaderboard';
        return;
      }
      netInfo.textContent='Syncing…';
      const [rBest, rRole] = await Promise.all([fetchBest(u), fetchRole(u)]);
      currentRole = rRole || (OWNER_USERNAMES.has(u)?'owner':null);
      const best=Math.max(localBest, rBest??0);
      userInfo.innerHTML='User: '+(u||'(not set)')+roleBadge(currentRole,u);
      highInfo.textContent='High: '+best;
      netInfo.textContent='Online';
    }

    // ====== GAME ======
    const player={x:180,y:550,width:40,height:40,speed:24,color:'lime'};
    let obstacles=[], baseObstacleSpeed=4, obstacleSpeed=baseObstacleSpeed;
    let score=0, gameOver=false, baseSpawnInterval=500, spawnInterval=baseSpawnInterval;
    let spawnTimer=null, paused=true, speedIncreaseTimer=null, maxObstacleSpeed=12;
    let keys={left:false,right:false}; let screen='home', lbOpen=false;

    // Cheats state
    const cheats={ godmode:false, reverse:false, rainbow:false, ghost:false, speedy:false, bigplayer:false, tinyplayer:false, slowmo:null, slowtime:null, fastspawn:null, timefreeze:false, turbo:false };
    let cheatedThisRun=false;
    const cheatColors={ godmode:'gold', reverse:'red', rainbow:null, ghost:'gray', speedy:'cyan', bigplayer:'orange', tinyplayer:'pink', slowmo:'lightblue', slowtime:'lightgreen', fastspawn:'violet', timefreeze:'white', turbo:'cyan' };

    const controlsEnabled=()=> screen==='playing' && !lbOpen && cheatBar.style.display!=='flex';

    function spawnObstacle(){ if(!paused && !gameOver && !cheats.timefreeze){ const w=Math.random()*60+20, x=Math.random()*(canvas.width-w); obstacles.push({x,y:cheats.reverse?(canvas.height+20):-20,width:w,height:20,color:'red'});}}
    function startSpawning(){ clearInterval(spawnTimer); spawnTimer=setInterval(spawnObstacle, spawnInterval); }
    function startSpeedIncrease(){ clearInterval(speedIncreaseTimer); speedIncreaseTimer=setInterval(()=>{ if(!paused&&!gameOver&&!cheats.timefreeze&&baseObstacleSpeed<maxObstacleSpeed){ baseObstacleSpeed+=0.5; refreshEffectiveSpeeds(); }}, 10000); }

    function refreshEffectiveSpeeds(){
      if(cheats.timefreeze){ obstacleSpeed = 0; }
      else { obstacleSpeed = (cheats.slowmo!=null) ? Number(cheats.slowmo) : (cheats.slowtime!=null ? Number(cheats.slowtime) : baseObstacleSpeed); }
      let newSpawn=baseSpawnInterval;
      if(cheats.fastspawn!=null) newSpawn=Number(cheats.fastspawn);
      else if(cheats.slowtime!=null) newSpawn=1500;
      if(newSpawn!==spawnInterval){ spawnInterval=newSpawn; startSpawning(); }
      if(cheats.turbo===false){ player.speed = cheats.speedy ? 35 : 24; }
    }

    function update(){ if(gameOver||paused||screen!=='playing') return;
      if(keys.left) player.x-=player.speed;
      if(keys.right) player.x+=player.speed;
      if(player.x<0) player.x=0;
      if(player.x+player.width>canvas.width) player.x=canvas.width-player.width;
      if(!cheats.timefreeze){
        obstacles.forEach(o=> o.y += (cheats.reverse? -obstacleSpeed : obstacleSpeed));
        obstacles = obstacles.filter(o=> o.y<canvas.height+40 && o.y>-40);
      }
      if(!cheats.godmode){
        for(const o of obstacles){
          if(player.x < o.x + o.width && player.x + player.width > o.x && player.y < o.y + o.height && player.y + player.height > o.y){
            onDeath(); break;
          }
        }
      }
      score += (cheats.reverse ? -1 : 1);
      if(cheats.rainbow){
        player.color = `hsl(${(Date.now()/10)%360},100%,50%)`;
        obstacles.forEach((o,i)=> o.color = `hsl(${(Date.now()/10 + i*20)%360},100%,50%)`);
      } else {
        player.color = cheats.ghost ? 'rgba(0,0,0,0)' : 'lime';
      }
    }

    function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle=player.color; ctx.fillRect(player.x,player.y,player.width,player.height);
      obstacles.forEach(o=>{ ctx.fillStyle=o.color; ctx.fillRect(o.x,o.y,o.width,o.height); });
      ctx.fillStyle='white'; ctx.font='20px Arial'; ctx.fillText('Score: '+score,10,30);
      const active = Object.keys(cheats).filter(c => cheats[c] || cheats[c]===0);
      if(active.length){
        ctx.font='14px Arial';
        active.forEach((c,i)=>{
          ctx.fillStyle=(c==='rainbow') ? `hsl(${(Date.now()/10)%360},100%,50%)` : (cheatColors[c]||'white');
          const val=(typeof cheats[c]==='number')?`(${cheats[c]})`:'';
          ctx.fillText(c+val, canvas.width-160, 20+i*16);
        });
      }
      if(gameOver){ ctx.fillStyle='yellow'; ctx.font='40px Arial'; ctx.fillText('GAME OVER',80,canvas.height/2); }
      if(paused || screen!=='playing'){ ctx.fillStyle='orange'; ctx.font='30px Arial'; ctx.fillText('PAUSED',150,canvas.height/2); }
    }
    (function loop(){ update(); draw(); requestAnimationFrame(loop); })();

    function goHome(){
      screen='home'; paused=true; gameOver=false; homeOverlay.style.display='flex';
      restartBtn.style.display='none'; backHomeBtn.style.display='none';
      clearInterval(spawnTimer); clearInterval(speedIncreaseTimer); closeCheatBar();
      document.body.style.overflow='auto';
    }
    function startPlaying(){
      if(!getUser()){ openNameModal(''); return; }
      screen='playing'; paused=false; gameOver=false; score=0; obstacles=[]; cheatedThisRun=false;
      player.x=180; player.width=40; player.height=40; player.speed=24;
      baseObstacleSpeed=4; obstacleSpeed=baseObstacleSpeed; baseSpawnInterval=500; spawnInterval=baseSpawnInterval;
      Object.keys(cheats).forEach(c=>cheats[c]=(typeof cheats[c]==='boolean'?false:null));
      homeOverlay.style.display='none'; restartBtn.style.display='none'; backHomeBtn.style.display='inline-block';
      startSpawning(); startSpeedIncrease(); refreshEffectiveSpeeds();
      document.body.style.overflow='hidden'; canvas.focus();
    }

    function saveBestLocal(u,s){ const scores=loadScoresLocal(); const prev=scores[u]||0; if(s>prev){ scores[u]=s; saveScoresLocal(scores);} }

    async function submitScore(u,s){
      saveBestLocal(u,s);
      if(!supabase){ await updateUserUI(true); return; }
      try{
        const currentBest = await fetchBest(u) ?? 0;
        const newBest = Math.max(currentBest, s);
        const { error } = await supabase.from('scores').upsert({ username:u, best:newBest }).select('best').maybeSingle();
        if(error){ showErr('E_DB_WRITE: '+error.message); await updateUserUI(); return; }
        await updateUserUI();
      }catch{ showErr('E_NET: Network error submitting score'); }
    }

    function onDeath(){
      if(gameOver) return;
      gameOver=true; clearInterval(spawnTimer); clearInterval(speedIncreaseTimer);
      const u=getUser(); if(u && (ALLOW_CHEATED_SCORES || !cheatedThisRun)) submitScore(u,score);
      restartBtn.style.display='inline-block'; showErr('E_DEAD: Hit a block — press Restart');
    }

    // ====== Leaderboard (working) ======
    async function openLeaderboard(){
      lbOverlay.style.display='flex'; lbOpen=true;
      lbTableBody.innerHTML='<tr><td colspan="3" style="text-align:center;opacity:.8;">Loading…</td></tr>';
      if(!supabase){
        const scores=loadScoresLocal();
        const rows=Object.keys(scores).map(u=>({username:u,best:scores[u]})).sort((a,b)=>b.best-a.best).slice(0,50);
        lbTableBody.innerHTML = rows.length ? rows.map((r,i)=>`<tr><td>${i+1}</td><td>${r.username}</td><td>${r.best}</td></tr>`).join('') : '<tr><td colspan="3" style="text-align:center;opacity:.8;">No scores yet</td></tr>';
        return;
      }
      try{
        const [{ data, error }, rolesRes] = await Promise.all([
          supabase.from('scores').select('username,best').order('best',{ascending:false}).limit(50),
          supabase.from('profiles').select('username,role')
        ]);
        if(error){ lbTableBody.innerHTML = `<tr><td colspan="3" style="text-align:center;opacity:.8;">Load error: ${error.message}</td></tr>`; return; }
        const rmap=new Map(); if(!rolesRes.error && rolesRes.data){ rolesRes.data.forEach(r=>rmap.set(r.username, r.role)); }
        lbTableBody.innerHTML = (data||[]).map((r,i)=>{
          const role=rmap.get(r.username) || (OWNER_USERNAMES.has(r.username)?'owner':null);
          return `<tr><td>${i+1}</td><td>${r.username}${role?` <span class="role ${role}" style="font-size:11px;text-transform:uppercase;">${role}</span>`:''}</td><td>${r.best}</td></tr>`;
        }).join('') || '<tr><td colspan="3" style="text-align:center;opacity:.8;">No scores yet</td></tr>';
      }catch(e){ lbTableBody.innerHTML = '<tr><td colspan="3" style="text-align:center;opacity:.8;">Network error</td></tr>'; }
    }
    function closeLeaderboard(){ lbOverlay.style.display='none'; lbOpen=false; }

    // ====== Cheats ======
    function showCheatBar(){ if(screen!=='playing') return; paused=true; cheatBar.style.display='flex'; setTimeout(()=>{ cheatInput.focus(); },0); }
    function closeCheatBar(){ cheatBar.style.display='none'; cheatInput.value=''; if(screen==='playing'&&!gameOver) paused=false; }
    function resolveName(name){ return (name||'').toLowerCase(); }
    function enableCheat(name, num){
      switch(name){
        case 'godmode': cheats.godmode=true; break;
        case 'reverse': cheats.reverse=true; break;
        case 'rainbow': cheats.rainbow=true; break;
        case 'ghost':   cheats.ghost=true; break;
        case 'speedy':  cheats.speedy=true; if(!cheats.turbo) player.speed=35; break;
        case 'bigplayer': cheats.bigplayer=true; player.width=80; player.height=80; break;
        case 'tinyplayer': cheats.tinyplayer=true; player.width=20; player.height=20; break;
        case 'slowmo': cheats.slowmo = (num!=null?num:1); break;
        case 'slowtime': cheats.slowtime = (num!=null?num:1); break;
        case 'fastspawn': cheats.fastspawn = (num!=null?num:200); break;
        case 'timefreeze': cheats.timefreeze=true; break;
        case 'turbo': cheats.turbo=true; player.speed = (num!=null?num:60); break;
        case 'points': score += (num!=null?num:1000); break;
        case 'clear': obstacles=[]; break;
        default: return false;
      }
      refreshEffectiveSpeeds(); return true;
    }
    function disableCheat(name){
      switch(name){
        case 'godmode': cheats.godmode=false; break;
        case 'reverse': cheats.reverse=false; break;
        case 'rainbow': cheats.rainbow=false; break;
        case 'ghost':   cheats.ghost=false; break;
        case 'speedy':  cheats.speedy=false; if(!cheats.turbo) player.speed=24; break;
        case 'bigplayer': case 'tinyplayer': cheats.bigplayer=false; cheats.tinyplayer=false; player.width=40; player.height=40; break;
        case 'slowmo': cheats.slowmo=null; break;
        case 'slowtime': cheats.slowtime=null; break;
        case 'fastspawn': cheats.fastspawn=null; break;
        case 'timefreeze': cheats.timefreeze=false; break;
        case 'turbo': cheats.turbo=false; player.speed = cheats.speedy?35:24; break;
        default: return false;
      }
      refreshEffectiveSpeeds(); return true;
    }
    function parseCheat(raw){
      const m = raw.match(/^([a-z]+)(\d+)?$/); if(!m) return null;
      return { base:m[1], num: m[2]?parseInt(m[2],10):null };
    }
    function applyCheatCodeRaw(raw){
      const str=(raw||'').trim().toLowerCase(); if(!str) return false;
      if(str.startsWith('disable ')){ const d=resolveName(str.slice(8).trim()); return disableCheat(d); }
      const p=parseCheat(str); if(!p) return false;
      const ok = enableCheat(p.base, p.num);
      if(ok && !['points','clear'].includes(p.base)) cheatedThisRun=true;
      return ok;
    }
    function applyCheatCode(){ const ok = applyCheatCodeRaw(cheatInput.value); closeCheatBar(); if(!ok) showErr('E_CHEAT_PARSE: Invalid code'); }

    // ====== INPUT BINDINGS ======
    function handle(id){
      switch(id){
        case 'playBtn': startPlaying(); break;
        case 'restartBtn': if(screen==='playing'){ startPlaying(); } break;
        case 'backHomeBtn': goHome(); break;
        case 'lbBtn': openLeaderboard(); break;
        case 'lbClose': closeLeaderboard(); break;
        case 'setNameBtn': openNameModal(getUser()); break;
        case 'nameSave': saveNameFromModal(); break;
        case 'nameCancel': closeNameModal(); break;
        case 'controlsBtn': controlsOverlay.style.display='flex'; break;
        case 'controlsClose': controlsOverlay.style.display='none'; break;
        case 'applyCheat': applyCheatCode(); break;
      }
    }
    ['playBtn','restartBtn','backHomeBtn','lbBtn','lbClose','setNameBtn','nameSave','nameCancel','controlsBtn','controlsClose','applyCheat']
      .forEach(id=>{ const el=$(id); if(el){ el.addEventListener('click', ()=>handle(id)); }});

    function usernameTap(e){ if(screen==='playing'){ e.preventDefault(); showCheatBar(); } else { openNameModal(getUser()); } }
    userInfo.addEventListener('click', usernameTap);
    userInfo.addEventListener('touchstart', (e)=>{ e.preventDefault(); usernameTap(e); }, {passive:false});

    // Drag controls
    let dragging=false;
    const canvasX = (clientX)=>{ const r=canvas.getBoundingClientRect(); const x=(clientX-r.left)*(canvas.width/r.width); return Math.max(0, Math.min(canvas.width-player.width, x-player.width/2)); };
    canvas.addEventListener('mousedown', e=>{ if(screen!=='playing') return; e.preventDefault(); dragging=true; player.x=canvasX(e.clientX); });
    window.addEventListener('mousemove', e=>{ if(dragging && screen==='playing'){ e.preventDefault(); player.x=canvasX(e.clientX); } });
    window.addEventListener('mouseup', ()=>{ dragging=false; });
    canvas.addEventListener('touchstart', e=>{ if(screen!=='playing') return; if(e.touches[0]){ e.preventDefault(); dragging=true; player.x=canvasX(e.touches[0].clientX);} }, {passive:false});
    canvas.addEventListener('touchmove', e=>{ if(dragging && e.touches[0]){ e.preventDefault(); player.x=canvasX(e.touches[0].clientX);} }, {passive:false});
    canvas.addEventListener('touchend', e=>{ e.preventDefault(); dragging=false; }, {passive:false});
    canvas.addEventListener('touchcancel', e=>{ e.preventDefault(); dragging=false; }, {passive:false});

    // Keyboard
    window.addEventListener('keydown', (e)=>{
      // Space toggles diagnostics HUD unless typing
      if ((e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') && !isTypingTarget(e.target)) {
        e.preventDefault(); diag.toggle(); return;
      }
      const typing = isTypingTarget(e.target) || (cheatBar.style.display==='flex');
      if((e.key==='e'||e.key==='E') && !isTypingTarget(e.target)){ e.preventDefault(); errEl.style.display = (errEl.style.display==='block' ? 'none' : 'block'); return; }
      if(screen==='playing' && !lbOpen && !typing){
        if(e.key==='ArrowLeft' || e.key==='Left' || e.keyCode===37){ e.preventDefault(); keys.left=true; }
        if(e.key==='ArrowRight' || e.key==='Right' || e.keyCode===39){ e.preventDefault(); keys.right=true; }
        if(e.key==='p' || e.key==='P' || e.keyCode===80){ e.preventDefault(); paused=!paused; }
      }
      if(e.key==='Shift' && screen==='playing' && cheatBar.style.display!=='flex'){ e.preventDefault(); showCheatBar(); }
      if(cheatBar.style.display==='flex'){
        if(e.key==='Enter'){ e.preventDefault(); applyCheatCode(); }
        if(e.key==='Escape'){ e.preventDefault(); closeCheatBar(); }
      }
      if(nameOverlay.style.display==='flex'){
        if(e.key==='Enter'){ e.preventDefault(); saveNameFromModal(); }
        if(e.key==='Escape'){ e.preventDefault(); closeNameModal(); }
      }
    });
    window.addEventListener('keyup', (e)=>{
      if(screen==='playing' && !lbOpen && !(isTypingTarget(e.target))){
        if(e.key==='ArrowLeft' || e.key==='Left' || e.keyCode===37){ e.preventDefault(); keys.left=false; }
        if(e.key==='ArrowRight' || e.key==='Right' || e.keyCode===39){ e.preventDefault(); keys.right=false; }
      }
    });

    // Init — force diagnostics hidden
    diagHUD.classList.add('hidden'); diagHUD.style.display='none';
    updateSetNameButton();
    await updateUserUI();
    goHome();
  </script>
</body>
</html>
