<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dodge the Blocks — v13.0 (Owner rank setter)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    :root { --green:#33ff66; --accent:#ff3dac; --scanline:rgba(255,255,255,0.06); }
    html, body { height: 100%; }
    body { margin: 0; background:#1a1a1a; display:flex; justify-content:center; align-items:center; color:#eee; font-family:"Courier New", monospace; }
    canvas { background:#0b0b0b; display:block; border:2px solid #2a2a2a; box-shadow:0 0 24px rgba(0,0,0,.6) inset; z-index:10; pointer-events:auto; touch-action:none; }
    .btn { font-family:inherit; font-weight:bold; padding:10px 18px; font-size:16px; cursor:pointer; margin:6px; border:2px solid var(--green); background:transparent; color:var(--green); text-shadow:0 0 6px rgba(51,255,102,.5); pointer-events:auto; transition:box-shadow .15s, background .15s, filter .15s; }
    .btn:hover { background: rgba(51,255,102,.18); box-shadow:0 0 8px rgba(51,255,102,.35); filter:brightness(1.05); }
    .btn-accent { border-color: var(--accent); color: var(--accent); text-shadow: 0 0 6px rgba(255,61,172,.6); }
    .btn-danger { border-color:#ff6b6b; color:#ff6b6b; text-shadow: 0 0 6px rgba(255,107,107,.6); }
    .btn.active, .btn[aria-pressed="true"] { background: rgba(51,255,102,.22); box-shadow:0 0 14px rgba(51,255,102,.6), inset 0 0 10px rgba(51,255,102,.25); filter:brightness(1.1); }
    #topBar { position:fixed; top:8px; left:8px; right:8px; display:flex; gap:12px; align-items:center; justify-content:space-between; z-index:60; font-size:14px; pointer-events:auto; }
    #userInfo { cursor:pointer; pointer-events:auto; }
    #homeOverlay { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; padding-top:56px;
      background: repeating-linear-gradient(0deg,transparent 0px, transparent 2px, var(--scanline) 3px, transparent 4px), radial-gradient(circle at 50% 20%, rgba(255,61,172,.12), transparent 40%), #050505;
      text-align:center; overflow:hidden; z-index:30; pointer-events:auto; }
    .retro-box { border:3px solid var(--green); box-shadow:0 0 24px rgba(51,255,102,.25), inset 0 0 12px rgba(51,255,102,.1); padding:22px 28px; background:#0c0c0c; }
    .corner { position:absolute; top:88px; right:16px; display:flex; gap:10px; pointer-events:auto; flex-wrap:wrap; max-width:70vw; justify-content:flex-end; z-index:35; }
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,.8); display:none; align-items:center; justify-content:center; z-index:80; pointer-events:auto; }
    .modal { width:720px; max-width:94vw; max-height:80vh; overflow:auto; background:#121212; border:2px solid var(--green); box-shadow:0 0 20px rgba(51,255,102,.3); border-radius:8px; padding:16px; }
    #errBanner { position:fixed; bottom:8px; left:8px; right:8px; background:#0e0e0e; color:#e3ffee; padding:8px 10px; border:1px solid #2dd562; border-radius:6px; font-size:12px; z-index:100; display:none; white-space:pre-wrap; }
    #restartBtn { display:none; position:fixed; top:8px; left:50%; transform:translateX(-50%); z-index:50; pointer-events:auto; }
    #cheatBar { position:fixed; bottom:60px; left:50%; transform:translateX(-50%); display:none; gap:8px; z-index:90; background:#0e0e0e; padding:8px 10px; border:1px solid #2a2a2a; border-radius:6px; }
    #cheatInput { padding:8px; font-size:14px; border:1px solid #3a3a3a; background:#0b0b0b; color:#fff; }
    #backHomeBtn { display:none; }
    .role-badge { color:#ff3dac; margin-left:4px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0; }
    input, select { background:#0b0b0b; color:#fff; border:1px solid #3a3a3a; padding:8px; }
    .section { border:1px solid #2a2a2a; padding:10px; border-radius:8px; margin:10px 0; }
    .section h4 { margin:0 0 8px 0; color:#9ad6ad; }
    .hint { font-size:12px; opacity:.8; }
  </style>
</head>
<body>
  <div id="topBar">
    <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
      <div id="userInfo" title="Tap while playing to open cheat bar">User: (not set)</div>
      <div id="highInfo">High: 0</div>
      <div id="netInfo"></div>
    </div>
    <div>
      <button id="errToggleBtn" class="btn" type="button" title="Toggle Errors">Errors</button>
      <button id="backHomeBtn" class="btn" type="button">⮐ Back to Home</button>
      <span id="verBadge" style="font-size:11px;opacity:.7;">build: v13.0</span>
    </div>
  </div>

  <canvas id="gameCanvas" width="400" height="600" tabindex="0" aria-label="Game canvas"></canvas>

  <div id="homeOverlay">
    <div class="retro-box">
      <div id="title" style="font-size:48px;color:#33ff66;text-shadow:0 0 8px rgba(51,255,102,.7);">DODGE THE BLOCKS</div>
      <div id="subtitle" style="margin-bottom:18px;color:#9ad6ad;">made by Ethan Fehler</div>
      <button id="playBtn" class="btn btn-accent" type="button">▶ PLAY</button>
      <div class="pressStart" style="color:#ff3dac;">PRESS PLAY TO START</div>
    </div>
    <div class="corner">
      <button id="lbBtn" class="btn" type="button">LEADERBOARD</button>
      <button id="controlsBtn" class="btn" type="button">CONTROLS</button>
      <button id="setNameBtn" class="btn" type="button">SET USERNAME</button>
      <button id="ownerMenuBtn" class="btn" type="button" style="display:none;">OWNER MOD MENU</button>
    </div>
  </div>

  <div id="lbOverlay" class="overlay">
    <div class="modal">
      <button id="lbClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Global Leaderboard</h3>
      <div id="lbStatus" style="font-size:12px;opacity:.8;margin-bottom:6px;"></div>
      <table id="lbTable" style="width:100%;border-collapse:collapse;">
        <thead><tr><th>#</th><th>User</th><th>Best Score</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div id="nameOverlay" class="overlay">
    <div class="modal">
      <button id="nameCancel" class="btn" type="button" style="float:right;">Close</button>
      <h3>Set your username</h3>
      <input id="nameInput" placeholder="e.g., Ethan Fehler" maxlength="20" autocomplete="off">
      <div id="nameErr" style="color:#ff6b6b;min-height:1.2em;font-size:12px;"></div>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
        <button id="nameSave" class="btn btn-accent" type="button">Save</button>
      </div>
    </div>
  </div>

  <div id="controlsOverlay" class="overlay">
    <div class="modal">
      <button id="controlsClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Keyboard & Touch Controls</h3>
      <ul style="line-height:1.6; margin:0 0 8px 16px;">
        <li>← / → — Move left / right (desktop)</li>
        <li>Drag finger on the canvas — Move the square (mobile)</li>
        <li>P — Pause / resume (gameplay only)</li>
        <li>Enter — Confirm username</li>
        <li>Esc — Close the current dialog</li>
        <li>E — Toggle error banner</li>
      </ul>
    </div>
  </div>

  <div id="ownerOverlay" class="overlay">
    <div class="modal" id="ownerModal">
      <button id="ownerClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Owner Mod Menu</h3>
      <div class="hint">Owner-only controls. PIN is required for role changes.</div>

      <div class="section">
        <h4>Quick Toggles</h4>
        <div class="row" id="ownerToggles">
          <button class="btn" data-ot="godmode" aria-pressed="false">Godmode</button>
          <button class="btn" data-ot="rainbow" aria-pressed="false">Rainbow</button>
          <button class="btn" data-ot="ghost" aria-pressed="false">Ghost</button>
          <button class="btn" data-ot="reverse" aria-pressed="false">Reverse</button>
          <button class="btn" data-ot="speedy" aria-pressed="false">Speedy</button>
          <button class="btn" data-ot="bigplayer" aria-pressed="false">Big</button>
          <button class="btn" data-ot="tinyplayer" aria-pressed="false">Tiny</button>
          <button class="btn" id="otResetSize">Reset Size</button>
          <button class="btn" id="otDefaults">Set All to Default</button>
        </div>
      </div>

      <div class="section">
        <h4>Score Tools</h4>
        <div class="row" id="ownerScores">
          <button class="btn" data-score="+1000">+1,000</button>
          <button class="btn" data-score="+10000">+10,000</button>
          <button class="btn" id="setBestCurrent">Set Best = Current</button>
        </div>
        <div class="row">
          <input id="bestX" placeholder="Best = X" style="width:140px;">
          <button class="btn" id="setBestX">Apply</button>
        </div>
      </div>

      <div class="section">
        <h4>Speed & Spawn</h4>
        <div class="row">
          <label>Obstacle Speed</label>
          <input type="range" id="speedRange" min="0" max="40" value="4" step="1">
          <span id="speedLabel">4</span>
        </div>
        <div class="row">
          <label>Spawn Interval (ms)</label>
          <input type="range" id="spawnRange" min="50" max="1500" value="500" step="10">
          <span id="spawnLabel">500</span>
        </div>
        <div class="row" id="ownerSpeedBtns">
          <button class="btn" data-slow="1">Slowmo 1</button>
          <button class="btn" data-slow="2">Slowmo 2</button>
          <button class="btn" data-slow="4">Slowmo 4</button>
          <button class="btn" data-slow="8">Slowmo 8</button>
          <button class="btn" data-fast="50">Fastspawn 50</button>
          <button class="btn" data-fast="100">Fastspawn 100</button>
          <button class="btn" data-fast="200">Fastspawn 200</button>
        </div>
      </div>

      <div class="section">
        <h4>Set My Leaderboard Position</h4>
        <div class="row">
          <input id="desiredRank" type="number" min="1" step="1" placeholder="Rank (1 = top)" style="width:160px;">
          <button class="btn btn-accent" id="applyDesiredRank">Place Me</button>
        </div>
        <div class="hint">We read the current leaderboard and set your <b>best</b> to one point below the person above you.<br>
        Example: if you pick rank 3 and #2 has 12,345, your best becomes 12,344.</div>
        <div id="rankMsg" class="hint"></div>
      </div>

      <div class="section">
        <h4>Roles</h4>
        <div class="row">
          <input id="targetUser" placeholder="username" style="width:160px;">
          <select id="targetRole">
            <option value="player">player</option>
            <option value="mod">mod</option>
            <option value="owner">owner</option>
          </select>
          <input id="customRole" placeholder="custom role (optional)" style="width:180px;">
          <input id="ownerPIN" type="password" placeholder="Owner PIN">
          <button class="btn btn-accent" id="applyRole">Apply Role</button>
        </div>
        <div id="pinMsg" class="hint"></div>
        <div class="row">
          <input id="removeUser" placeholder="username" style="width:160px;">
          <input id="removePIN" type="password" placeholder="Owner PIN">
          <button class="btn btn-danger" id="removeRoleBtn">Remove Role</button>
        </div>
        <div id="removeMsg" class="hint"></div>
      </div>
    </div>
  </div>

  <div id="cheatBar"><input type="password" id="cheatInput" placeholder="Enter cheat code"><button id="applyCheat" class="btn" type="button">Apply</button></div>
  <button id="restartBtn" class="btn" type="button">Restart</button>

  <div id="errBanner"></div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.43.1/dist/umd/supabase.js"></script>
  <script>
    const SUPABASE_URL = "https://staohtadlbeextexepdz.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN0YW9odGFkbGJlZXh0ZXhlcGR6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2MjAwNTIsImV4cCI6MjA3MDE5NjA1Mn0.OLQ3GIM4JV8oajuczviBsM-ueoJWV6ro65NIjpjYq0U";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  </script>

  <script>
  (function(){
    const OWNER_USERNAMES = new Set(["Ethan Fehler"]);
    const PROTECTED_NAMES = new Set(["Ethan Fehler"]);

    const errEl = document.getElementById('errBanner');
    function showErr(msg){ errEl.textContent = '⚠ ' + msg; errEl.style.display = 'block'; console.warn(msg); }
    function hideErr(){ errEl.style.display='none'; }
    window.onerror = function(m, s, l, c){ showErr('JS_ERROR: '+m+' @'+l+':'+c); };
    window.onunhandledrejection = function(ev){ showErr('PROMISE_REJECTION: '+(ev&&ev.reason&&ev.reason.message||ev&&ev.reason||'unknown')); };

    const $ = (id)=>document.getElementById(id);
    const userInfo=$('userInfo'), highInfo=$('highInfo'), netInfo=$('netInfo');
    const homeOverlay=$('homeOverlay'), controlsOverlay=$('controlsOverlay');
    const lbOverlay=$('lbOverlay'), nameOverlay=$('nameOverlay');
    const ownerOverlay=$('ownerOverlay'), ownerModal=$('ownerModal');
    const nameInput=$('nameInput'), nameErr=$('nameErr');
    const canvas=$('gameCanvas'), ctx=canvas.getContext('2d');
    const restartBtn=$('restartBtn'), backHomeBtn=$('backHomeBtn');
    const cheatBar=$('cheatBar'), cheatInput=$('cheatInput');
    const lbStatus=$('lbStatus');
    const ownerMenuBtn=$('ownerMenuBtn');
    const errToggleBtn=$('errToggleBtn');

    const loadScoresLocal=()=>{ try{return JSON.parse(localStorage.getItem('dodge_scores')||'{}');}catch{return{};} };
    const saveScoresLocal=o=> localStorage.setItem('dodge_scores', JSON.stringify(o));
    const getUser=()=> (localStorage.getItem('dodge_user')||'').trim();
    const setUser=u=> localStorage.setItem('dodge_user', u);

    async function ensureProfile(u){
      if(!u) return { role:'player' };
      await supabase.from('profiles').upsert({ username:u }).select().maybeSingle();
      const { data } = await supabase.from('profiles').select('role').eq('username', u).maybeSingle();
      return { role: data?.role || 'player' };
    }
    function renderUserInfoBadge(u, role){
      const tag = role && role!=='player' ? ` <span class="role-badge">[${role}]</span>` : '';
      userInfo.innerHTML = 'User: ' + (u || '(not set)') + tag;
      const showOwner = role==='owner' || OWNER_USERNAMES.has(u);
      ownerMenuBtn.style.display = showOwner ? 'inline-block' : 'none';
    }
    async function refreshUserRoleUI(){
      const u=getUser();
      const { role } = await ensureProfile(u);
      renderUserInfoBadge(u, role);
      return role;
    }

    const player={x:180,y:550,width:40,height:40,speed:24,color:'lime'};
    let obstacles=[], baseObstacleSpeed=4, obstacleSpeed=baseObstacleSpeed;
    let score=0, gameOver=false, baseSpawnInterval=500, spawnInterval=baseSpawnInterval;
    let spawnTimer=null, paused=true, speedIncreaseTimer=null, maxObstacleSpeed=12;
    let keys={left:false,right:false}; let screen='home', lbOpen=false;
    let currentRole='player';

    const cheats={ godmode:false, reverse:false, rainbow:false, ghost:false, speedy:false, bigplayer:false, tinyplayer:false, slowmo:null, slowtime:null, fastspawn:null };
// Owner preset cheats persist between runs and are applied on Start
const ownerPresetCheats = { godmode:false, reverse:false, rainbow:false, ghost:false, speedy:false, bigplayer:false, tinyplayer:false, slowmo:null, slowtime:null, fastspawn:null };
    let cheatedThisRun=false;

    async function updateUserUI(){
      const u=getUser();
      if(!u){
        highInfo.textContent='High: 0';
        renderUserInfoBadge(u, 'player');
        netInfo.textContent = 'Online (no user)';
        currentRole='player';
        return;
      }
      const localBest = (loadScoresLocal()[u] || 0);
      const { data, error } = await supabase.from('scores').select('best').eq('username', u).maybeSingle();
      const remoteBest = error ? 0 : (data?.best || 0);
      highInfo.textContent='High: '+Math.max(localBest, remoteBest);
      netInfo.textContent = error ? 'Online (read error)' : 'Online';
      const { role } = await ensureProfile(u);
      currentRole = role || (OWNER_USERNAMES.has(u) ? 'owner' : 'player');
      renderUserInfoBadge(u, currentRole);
    }

    function openNameModal(prefill=''){ nameOverlay.style.display='flex'; nameInput.value=prefill; nameErr.textContent=''; setTimeout(()=>{ try{nameInput.focus();}catch{} },0); }
    function closeNameModal(){ nameOverlay.style.display='none'; }
    window.openNameModal = openNameModal; window.closeNameModal = closeNameModal;

    function saveBestLocal(u,s){ const scores=loadScoresLocal(); const prev=scores[u]||0; if(s>prev){ scores[u]=s; saveScoresLocal(scores); } }

    function onDeath(){
      if(gameOver) return;
      gameOver=true; clearInterval(spawnTimer); clearInterval(speedIncreaseTimer);
      const u=getUser(); if(u) saveBestLocal(u,score);
      restartBtn.style.display='inline-block';
      try{ submitScore(u, score); }catch{}
      showErr('E_DEAD: Hit a block — press Restart');
    }

    function spawnObstacle(){ if(!paused && !gameOver){ const w=Math.random()*60+20, x=Math.random()*(canvas.width-w); obstacles.push({x, y: cheats.reverse? canvas.height+20 : -20, width:w, height:20, color:'red'});} }
    function startSpawning(){ clearInterval(spawnTimer); spawnTimer=setInterval(spawnObstacle, spawnInterval); }
    function startSpeedIncrease(){ clearInterval(speedIncreaseTimer); speedIncreaseTimer=setInterval(()=>{ if(!paused && !gameOver && baseObstacleSpeed<maxObstacleSpeed){ baseObstacleSpeed+=0.5; refreshEffectiveSpeeds(); } },10000); }
    function refreshEffectiveSpeeds(){
      if (cheats.slowmo != null) obstacleSpeed = Number(cheats.slowmo);
      else if (cheats.slowtime != null) obstacleSpeed = Number(cheats.slowtime);
      else obstacleSpeed = baseObstacleSpeed;
      let newSpawn = baseSpawnInterval;
      if (cheats.fastspawn != null) newSpawn = Number(cheats.fastspawn);
      else if (cheats.slowtime != null) newSpawn = 1500;
      if (newSpawn !== spawnInterval){ spawnInterval = newSpawn; startSpawning(); }
      updateOwnerMenuUI();
    }
    function update(){
      if(gameOver||paused||screen!=='playing') return;
      if(keys.left) player.x-=player.speed;
      if(keys.right) player.x+=player.speed;
      if(player.x<0) player.x=0;
      if(player.x+player.width>canvas.width) player.x=canvas.width-player.width;
      obstacles.forEach(o=> o.y += (cheats.reverse? -obstacleSpeed : obstacleSpeed));
      obstacles = obstacles.filter(o=> o.y<canvas.height+40 && o.y>-40);
      if(!cheats.godmode){
        for(const o of obstacles){
          if(player.x < o.x + o.width && player.x + player.width > o.x && player.y < o.y + o.height && player.y + player.height > o.y){
            onDeath(); break;
          }
        }
      }
      score += (cheats.reverse ? -1 : 1);
      if(cheats.rainbow){
        player.color = `hsl(${(Date.now()/10)%360},100%,50%)`;
        obstacles.forEach((o,i)=> o.color = `hsl(${(Date.now()/10 + i*20)%360},100%,50%)`);
      } else {
        player.color = cheats.ghost ? 'rgba(0,0,0,0)' : 'lime';
      }
    }
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle=player.color; ctx.fillRect(player.x,player.y,player.width,player.height);
      obstacles.forEach(o=>{ ctx.fillStyle=o.color; ctx.fillRect(o.x,o.y,o.width,o.height); });
      ctx.fillStyle='white'; ctx.font='20px Arial'; ctx.fillText('Score: '+score,10,30);
      const active = Object.entries(cheats).filter(([k,v]) => v === true || v === 0 || (typeof v === 'number')).map(([k,v]) => typeof v === 'number' ? `${k}(${v})` : k);
      if(active.length){
        ctx.font = '14px Arial'; ctx.textAlign = 'right'; ctx.textBaseline='top';
        active.forEach((label, i) => { ctx.fillStyle = label.startsWith('rainbow') ? `hsl(${(Date.now()/10)%360},100%,50%)` : '#ffffff'; ctx.fillText(label, canvas.width-8, 8+i*16); });
        ctx.textAlign='left'; ctx.textBaseline='alphabetic';
      }
      if(gameOver){ ctx.fillStyle='yellow'; ctx.font='40px Arial'; ctx.fillText('GAME OVER',80,canvas.height/2); }
      if(paused || screen!=='playing'){ ctx.fillStyle='orange'; ctx.font='30px Arial'; ctx.fillText('PAUSED',150,canvas.height/2); }
    }
    (function loop(){ update(); draw(); requestAnimationFrame(loop); })();

    function goHome(){ screen='home'; paused=true; gameOver=false; homeOverlay.style.display='flex'; backHomeBtn.style.display='none'; restartBtn.style.display='none'; clearInterval(spawnTimer); clearInterval(speedIncreaseTimer); document.body.style.overflow='auto'; }
    function startPlaying(){
      if(!getUser()){ openNameModal(''); return; }
      screen='playing'; paused=false; gameOver=false; score=0; obstacles=[]; cheatedThisRun=false;
      player.x=180; player.width=40; player.height=40; player.speed=24;
      baseObstacleSpeed=4; obstacleSpeed=baseObstacleSpeed; baseSpawnInterval=500; spawnInterval=baseSpawnInterval;
      // Apply owner presets on new run
for (const k in ownerPresetCheats) { cheats[k] = ownerPresetCheats[k]; }
// Apply size/speed effects from presets
if (cheats.speedy) { player.speed = 35; } else { player.speed = 24; }
if (cheats.bigplayer) { player.width=80; player.height=80; }
else if (cheats.tinyplayer) { player.width=20; player.height=20; }
else { player.width=40; player.height=40; }
      homeOverlay.style.display='none'; backHomeBtn.style.display='inline-block'; restartBtn.style.display='none';
      startSpawning(); startSpeedIncrease(); refreshEffectiveSpeeds();
      document.body.style.overflow='hidden'; canvas.focus();
      hideErr();
      updateOwnerMenuUI();
    }
    window.goHome=goHome; window.startPlaying=startPlaying;

    async function submitScore(u, s){
      if(!u){ updateUserUI(); return; }
      const scores = loadScoresLocal(); scores[u] = Math.max(scores[u]||0, s); saveScoresLocal(scores);
      const { data, error } = await supabase.from('scores').select('best').eq('username', u).maybeSingle();
      const remoteBest = error ? 0 : (data?.best || 0);
      const newBest = Math.max(remoteBest, s);
      if(newBest > remoteBest){
        await supabase.from('scores').upsert({ username: u, best: newBest }).select('best').maybeSingle();
      }
      await updateUserUI();
      if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
    }

    async function openLeaderboard(){
      const tbody = document.querySelector('#lbTable tbody');
      lbStatus.textContent = '';
      tbody.innerHTML = '<tr><td colspan="3" style="text-align:center;opacity:.8;">Loading…</td></tr>';

      const rowsRes = await supabase.from('scores').select('username,best').order('best', { ascending:false }).limit(50);
      if(rowsRes.error){ tbody.innerHTML = `<tr><td colspan="3" style="text-align:center;opacity:.8;">Load error: ${rowsRes.error.message}</td></tr>`; lbOverlay.style.display='flex'; lbOpen=true; return; }
      const rows = rowsRes.data||[];
      if(!rows.length){ tbody.innerHTML = '<tr><td colspan="3" style="text-align:center;opacity:.8;">No scores yet</td></tr>'; lbOverlay.style.display='flex'; lbOpen=true; return; }

      const names = rows.map(r=>r.username);
      const profsRes = await supabase.from('profiles').select('username,role').in('username', names);
      if(profsRes.error){ lbStatus.textContent = 'Profiles read limited: ' + profsRes.error.message; }
      const roleMap = new Map((profsRes.data||[]).map(p=>[p.username,p.role]));

      tbody.innerHTML = rows.map((r,i)=>{ 
        const role = roleMap.get(r.username);
        const badge = role && role!=='player' ? ` <span class="role-badge">[${role}]</span>` : '';
        return `<tr><td>${i+1}</td><td>${r.username}${badge}</td><td>${r.best}</td></tr>`;
      }).join('');

      lbOverlay.style.display='flex'; lbOpen=true;
    }
    function closeLeaderboard(){ lbOverlay.style.display='none'; lbOpen=false; }
    window.openLeaderboard=openLeaderboard; window.closeLeaderboard=closeLeaderboard;

    function showCheatBar(){ if(screen!=='playing') return; paused=true; cheatBar.style.display='flex'; setTimeout(()=>{ try{cheatInput.focus();}catch{} },0); }
    function closeCheatBar(){ cheatBar.style.display='none'; cheatInput.value=''; if(screen==='playing'&&!gameOver) paused=false; }
    async function applyCheatCode(){
      const raw=(cheatInput.value||'').trim().toLowerCase(); if(!raw){ closeCheatBar(); return; }
      if(raw.startsWith('disable ')){
        const d=raw.slice(8).trim();
        if(d==='godmode') cheats.godmode=false;
        if(d==='reverse') cheats.reverse=false;
        if(d==='rainbow') cheats.rainbow=false;
        if(d==='ghost') cheats.ghost=false;
        if(d==='speedy') { cheats.speedy=false; player.speed=24; }
        if(d==='bigplayer' || d==='tinyplayer'){ cheats.bigplayer=false; cheats.tinyplayer=false; player.width=40; player.height=40; }
        if(d==='slowmo') cheats.slowmo=null;
        if(d==='slowtime') cheats.slowtime=null;
        if(d==='fastspawn') cheats.fastspawn=null;
        refreshEffectiveSpeeds(); updateOwnerMenuUI(); closeCheatBar(); return;
      }
      const m=raw.match(/^([a-z]+)(\d+)?$/); if(!m){ closeCheatBar(); return; }
      const base=m[1], num=m[2]?parseInt(m[2],10):null;
      if(base in cheats && typeof cheats[base]==='boolean'){
        cheats[base]=true;
        if(base==='speedy') player.speed=35;
        if(base==='bigplayer'){ player.width=80; player.height=80; }
        if(base==='tinyplayer'){ player.width=20; player.height=20; }
      } else if(base==='points'){
        score += (num!=null?num:1000);
      } else if(base==='slowmo'){
        cheats.slowmo = (num!=null?num:1);
      } else if(base==='slowtime'){
        cheats.slowtime = (num!=null?num:1);
      } else if(base==='fastspawn'){
        cheats.fastspawn = (num!=null?num:200);
      } else if(base==='clear'){
        obstacles = [];
      }
      refreshEffectiveSpeeds();
      updateOwnerMenuUI();
      closeCheatBar();
    }
    window.applyCheatCode=applyCheatCode;

    function updateOwnerMenuUI(){
      ownerModal.querySelectorAll('[data-ot]').forEach(btn=>{
        const key = btn.getAttribute('data-ot');
        const on = !!ownerPresetCheats[key];
        btn.classList.toggle('active', on);
        btn.setAttribute('aria-pressed', on ? 'true' : 'false');
      });
      const sr = $('speedRange'), sl = $('speedLabel'), spr=$('spawnRange'), spl=$('spawnLabel');
      if(sr){ sr.value = String(baseObstacleSpeed); if(sl) sl.textContent = String(baseObstacleSpeed); }
      if(spr){ spr.value = String(baseSpawnInterval); if(spl) spl.textContent = String(baseSpawnInterval); }
    }

    function bind(id, fn){ const el=$(id); if(!el) return; el.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); fn(e); }, {passive:false}); }
    bind('playBtn', startPlaying);
    bind('lbBtn', openLeaderboard);
    bind('lbClose', closeLeaderboard);
    bind('setNameBtn', ()=> openNameModal(getUser()));
    bind('nameSave', async ()=>{ 
      const desired=(nameInput.value||'').trim(); 
      if(!desired){ nameErr.textContent='Please enter a username.'; return; }
      let needsPIN = PROTECTED_NAMES.has(desired);
      try{ 
        const prof = await supabase.from('profiles').select('role').eq('username', desired).maybeSingle();
        if(prof.data && prof.data.role==='owner') needsPIN = true;
      }catch(e){ /* ignore */ }
      if(needsPIN){ 
        const pin = window.prompt('Owner PIN required to use this name:');
        if(!pin) return;
        try{ 
          const { data, error } = await supabase.rpc('verify_owner_pin', { pin });
          if(error || !data){ nameErr.textContent='Wrong PIN.'; return; }
        }catch(e){ nameErr.textContent='PIN check failed.'; return; }
      }
      setUser(desired);
      await supabase.from('profiles').upsert({ username: desired });
      closeNameModal(); 
      await refreshUserRoleUI(); 
      updateUserUI(); 
      const b=$('setNameBtn'); if(b) b.textContent='EDIT USERNAME'; 
    });
    bind('nameCancel', closeNameModal);
    bind('controlsBtn', ()=> { controlsOverlay.style.display='flex'; });
    bind('controlsClose', ()=> { controlsOverlay.style.display='none'; });
    bind('restartBtn', ()=> { if(screen==='playing') startPlaying(); });
    bind('backHomeBtn', goHome);
    bind('applyCheat', applyCheatCode);
    bind('ownerMenuBtn', ()=> { ownerOverlay.style.display='flex'; updateOwnerMenuUI(); });
    bind('ownerClose', ()=> { ownerOverlay.style.display='none'; });

    // Defaults & reset size buttons
    bind('otDefaults', ()=>{
      for (const k in ownerPresetCheats){ ownerPresetCheats[k] = (typeof ownerPresetCheats[k]==='boolean') ? false : null; }
      // keep typical defaults for gameplay
      ownerPresetCheats.godmode=false; ownerPresetCheats.reverse=false; ownerPresetCheats.rainbow=false; ownerPresetCheats.ghost=false;
      ownerPresetCheats.speedy=false; ownerPresetCheats.bigplayer=false; ownerPresetCheats.tinyplayer=false;
      ownerPresetCheats.slowmo=null; ownerPresetCheats.slowtime=null; ownerPresetCheats.fastspawn=null;
      if(screen==='playing'){ for (const k in ownerPresetCheats) cheats[k] = ownerPresetCheats[k]; player.speed=24; player.width=40; player.height=40; refreshEffectiveSpeeds(); }
      updateOwnerMenuUI();
    });
    bind('otResetSize', ()=>{
      ownerPresetCheats.bigplayer=false; ownerPresetCheats.tinyplayer=false;
      if(screen==='playing'){ cheats.bigplayer=false; cheats.tinyplayer=false; player.width=40; player.height=40; }
      updateOwnerMenuUI();
    });

    bind('applyRole', async ()=>{ 
      const target=($('targetUser').value||'').trim(); 
      const dropdown=($('targetRole').value||'player'); 
      const custom=($('customRole').value||'').trim();
      const role = custom || dropdown;
      const pin=($('ownerPIN').value||'').trim(); 
      if(!target||!pin){ $('pinMsg').textContent='Enter username and PIN.'; return; } 
      const { data, error } = await supabase.rpc('grant_role', { target_username: target, new_role: role, pin }); 
      $('pinMsg').textContent = error ? ('Error: '+error.message) : ('Applied! ' + target + ' → ' + role); 
      await refreshUserRoleUI(); 
    });
    bind('removeRoleBtn', async ()=>{
      const target=($('removeUser').value||'').trim();
      const pin=($('removePIN').value||'').trim();
      if(!target||!pin){ $('removeMsg').textContent='Enter username and PIN.'; return; }
      const { data, error } = await supabase.rpc('grant_role', { target_username: target, new_role: 'player', pin });
      $('removeMsg').textContent = error ? ('Error: '+error.message) : ('Removed: ' + target + ' is now player');
      await refreshUserRoleUI();
    });
    bind('errToggleBtn', ()=> { errEl.style.display = (errEl.style.display==='block' ? 'none' : 'block'); });

    // NEW: Set desired leaderboard rank
    bind('applyDesiredRank', async ()=>{
      const rankStr = (document.getElementById('desiredRank').value||'').trim();
      const desiredRank = parseInt(rankStr,10);
      const u = getUser();
      if(!u || !Number.isFinite(desiredRank) || desiredRank<1){ document.getElementById('rankMsg').textContent='Enter a valid rank (1 or higher).'; return; }
      // Fetch top 200 to be safe
      const { data: rows, error } = await supabase.from('scores').select('username,best').order('best',{ascending:false}).limit(200);
      if(error){ document.getElementById('rankMsg').textContent = 'Read error: '+error.message; return; }
      if(!rows || rows.length===0){
        // no scores -> set to 1
        await supabase.from('scores').upsert({ username:u, best: 1 }).select('best');
        await updateUserUI(); if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
        document.getElementById('rankMsg').textContent='Placed at rank 1 with 1 point.';
        return;
      }
      // If desired rank is 1 -> set to (top + 1)
      if(desiredRank===1){
        const topBest = rows[0].best || 0;
        const newBest = topBest + 1;
        await supabase.from('scores').upsert({ username:u, best: newBest }).select('best');
        await updateUserUI(); if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
        document.getElementById('rankMsg').textContent='Placed at rank 1 with '+newBest+'.';
        return;
      }
      // If desired rank is beyond list length, aim to be last (below current last)
      if(desiredRank > rows.length){
        const lastBest = rows[rows.length-1].best || 0;
        const newBest = Math.max(0, lastBest - 1);
        await supabase.from('scores').upsert({ username:u, best: newBest }).select('best');
        await updateUserUI(); if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
        document.getElementById('rankMsg').textContent='Placed near bottom with '+newBest+'.';
        return;
      }
      // Otherwise set to one below the person currently above that position
      const aboveIndex = desiredRank - 2; // 0-based index of the person above desired position
      const aboveBest = rows[aboveIndex]?.best ?? 0;
      let newBest = Math.max(0, aboveBest - 1);
      // make sure we don't collide into equal scores above you
      while(newBest>0 && rows.some(r => r.best === newBest && r.username !== u)){ newBest -= 1; }
      await supabase.from('scores').upsert({ username:u, best: newBest }).select('best');
      await updateUserUI(); if (lbOverlay.style.display === 'flex') { await openLeaderboard(); }
      document.getElementById('rankMsg').textContent='Placed at ~rank '+desiredRank+' with '+newBest+'.';
    });

    // Delegated clicks inside owner modal for toggles & speed presets
    ownerModal.addEventListener('click', (e)=>{
      const t = e.target.closest('button');
      if(!t) return;
      if(t.hasAttribute('data-ot')){
        e.preventDefault(); e.stopPropagation();
        const key = t.getAttribute('data-ot');
        if(!(key in ownerPresetCheats)) return;
        const newVal = !ownerPresetCheats[key];
        // enforce exclusives for size
        if(key==='bigplayer' && newVal){ ownerPresetCheats.bigplayer=true; ownerPresetCheats.tinyplayer=false; }
        else if(key==='tinyplayer' && newVal){ ownerPresetCheats.tinyplayer=true; ownerPresetCheats.bigplayer=false; }
        else { ownerPresetCheats[key] = newVal; }
        // also reflect in live cheats if currently playing
        if(screen==='playing'){
          cheats[key] = (key==='bigplayer'||key==='tinyplayer') ? ownerPresetCheats[key] : newVal;
          if(key==='bigplayer' && newVal){ cheats.tinyplayer=false; player.width=80; player.height=80; }
          if(key==='tinyplayer' && newVal){ cheats.bigplayer=false; player.width=20; player.height=20; }
          if((key==='bigplayer' || key==='tinyplayer') && !newVal){ player.width=40; player.height=40; }
          if(key==='speedy'){ player.speed = newVal ? 35 : 24; }
          refreshEffectiveSpeeds();
        }
        updateOwnerMenuUI();
        return;
      }
      if(t.hasAttribute('data-score')){
        e.preventDefault(); e.stopPropagation();
        const v = parseInt(t.getAttribute('data-score').replace('+',''),10);
        if(Number.isFinite(v)) score += v;
        return;
      }
      if(t.hasAttribute('data-slow')){
        e.preventDefault(); e.stopPropagation();
        ownerPresetCheats.slowmo = parseInt(t.getAttribute('data-slow'),10); ownerPresetCheats.slowtime=null; cheats.slowmo = ownerPresetCheats.slowmo; cheats.slowtime=null; refreshEffectiveSpeeds(); return;
      }
      if(t.hasAttribute('data-fast')){
        e.preventDefault(); e.stopPropagation();
        ownerPresetCheats.fastspawn = parseInt(t.getAttribute('data-fast'),10); cheats.fastspawn = ownerPresetCheats.fastspawn; refreshEffectiveSpeeds(); return;
      }
    }, {passive:false});

    // Sliders
    const speedRange=$('speedRange'), spawnRange=$('spawnRange');
    if(speedRange) speedRange.addEventListener('input', (e)=>{ $('speedLabel').textContent=e.target.value; baseObstacleSpeed=parseInt(e.target.value,10); cheats.slowmo=null; ownerPresetCheats.slowmo=null; refreshEffectiveSpeeds(); }, {passive:true});
    if(spawnRange) spawnRange.addEventListener('input', (e)=>{ $('spawnLabel').textContent=e.target.value; baseSpawnInterval=parseInt(e.target.value,10); cheats.fastspawn=null; ownerPresetCheats.fastspawn=null; refreshEffectiveSpeeds(); }, {passive:true});

    // User info click & mobile drag, keys
    userInfo.addEventListener('click', function(){ if(screen==='playing'){ showCheatBar(); } else { openNameModal(getUser()); } }, {passive:true});

    let dragging=false;
    const canvasX = (clientX)=>{ const r=canvas.getBoundingClientRect(); const x=(clientX-r.left)*(canvas.width/r.width); return Math.max(0, Math.min(canvas.width-player.width, x-player.width/2)); };
    canvas.addEventListener('mousedown', e=>{ if(screen!=='playing') return; e.preventDefault(); dragging=true; player.x=canvasX(e.clientX); }, {passive:false});
    window.addEventListener('mousemove', e=>{ if(dragging && screen==='playing'){ e.preventDefault(); player.x=canvasX(e.clientX); } }, {passive:false});
    window.addEventListener('mouseup', ()=>{ dragging=false; }, {passive:true});
    canvas.addEventListener('touchstart', e=>{ if(screen!=='playing') return; if(e.touches[0]){ e.preventDefault(); dragging=true; player.x=canvasX(e.touches[0].clientX);} }, {passive:false});
    canvas.addEventListener('touchmove', e=>{ if(dragging && e.touches[0]){ e.preventDefault(); player.x=canvasX(e.touches[0].clientX);} }, {passive:false});
    canvas.addEventListener('touchend', e=>{ e.preventDefault(); dragging=false; }, {passive:false});
    canvas.addEventListener('touchcancel', e=>{ e.preventDefault(); dragging=false; }, {passive:false});

    function isTypingTarget(t){ return t && (t.tagName==='INPUT' || t.tagName==='TEXTAREA' || t.isContentEditable); }
    window.addEventListener('keydown', (e)=>{
      if((e.key==='e'||e.key==='E') && !isTypingTarget(e.target)){ e.preventDefault(); errEl.style.display = (errEl.style.display==='block' ? 'none' : 'block'); return; }
      const typing = isTypingTarget(e.target) || (cheatBar.style.display==='flex');
      if(screen==='playing' && !lbOpen && !typing){
        if(e.key==='ArrowLeft' || e.key==='Left' || e.keyCode===37){ e.preventDefault(); keys.left=true; }
        if(e.key==='ArrowRight' || e.key==='Right' || e.keyCode===39){ e.preventDefault(); keys.right=true; }
        if(e.key==='p' || e.key==='P' || e.keyCode===80){ e.preventDefault(); paused=!paused; }
        if(e.key==='Shift'){ e.preventDefault(); showCheatBar(); }
      }
      if(cheatBar.style.display==='flex'){
        if(e.key==='Enter'){ e.preventDefault(); applyCheatCode(); }
        if(e.key==='Escape'){ e.preventDefault(); closeCheatBar(); }
      }
      if(nameOverlay.style.display==='flex'){
        if(e.key==='Enter'){ e.preventDefault(); const ev=new Event('click'); $('nameSave').dispatchEvent(ev); }
        if(e.key==='Escape'){ e.preventDefault(); closeNameModal(); }
      }
    }, {passive:false});
    window.addEventListener('keyup', (e)=>{ if(screen==='playing' && !lbOpen && !(isTypingTarget(e.target))){ if(e.key==='ArrowLeft' || e.key==='Left' || e.keyCode===37){ e.preventDefault(); keys.left=false; } if(e.key==='ArrowRight' || e.key==='Right' || e.keyCode===39){ e.preventDefault(); keys.right=false; } } }, {passive:false});

    (async function init(){ const b=$('setNameBtn'); if(b) b.textContent=getUser()?'EDIT USERNAME':'SET USERNAME'; try{ await updateUserUI(); }catch(e){ showErr('INIT_ERR: '+(e.message||e)); } })();
  })();
  </script>
</body>
</html>
