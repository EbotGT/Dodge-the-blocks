<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dodge the Blocks — Diagnostics Build</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    :root { --green:#33ff66; --accent:#ff3dac; --scanline:rgba(255,255,255,0.06); }
    html, body { height: 100%; }
    body { margin: 0; background:#1a1a1a; display:flex; justify-content:center; align-items:center; color:#eee; font-family:"Courier New", monospace; }
    canvas { background:#0b0b0b; display:block; border:2px solid #2a2a2a; box-shadow:0 0 24px rgba(0,0,0,.6) inset; z-index:1; pointer-events:auto; touch-action:none; }
    .btn { font-family:inherit; font-weight:bold; padding:12px 22px; font-size:18px; cursor:pointer; margin:6px; border:2px solid var(--green); background:transparent; color:var(--green); text-shadow:0 0 6px rgba(51,255,102,.5); }
    .btn:hover { background: rgba(51,255,102,.1); }
    .btn-accent { border-color: var(--accent); color: var(--accent); text-shadow: 0 0 6px rgba(255,61,172,.6); }
    #topBar { position:fixed; top:8px; left:8px; right:8px; display:flex; gap:8px; align-items:center; justify-content:space-between; z-index:40; font-size:14px; }
    #userInfo { cursor:pointer; }
    #homeOverlay { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: repeating-linear-gradient(0deg,transparent 0px, transparent 2px, var(--scanline) 3px, transparent 4px), radial-gradient(circle at 50% 20%, rgba(255,61,172,.12), transparent 40%), #050505;
      text-align:center; overflow:hidden; z-index:30; }
    .retro-box { border:3px solid var(--green); box-shadow:0 0 24px rgba(51,255,102,.25), inset 0 0 12px rgba(51,255,102,.1); padding:22px 28px; background:#0c0c0c; }
    .corner { position:absolute; top:16px; right:16px; display:flex; gap:8px; }
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,.8); display:none; align-items:center; justify-content:center; z-index:70; }
    .modal { width:560px; max-width:92vw; max-height:75vh; overflow:auto; background:#121212; border:2px solid var(--green); box-shadow:0 0 20px rgba(51,255,102,.3); border-radius:8px; padding:16px; }
    #errBanner { position:fixed; bottom:8px; left:8px; right:8px; background:#0e1010; color:#e3ffee; padding:8px 10px; border:1px solid #2dd562; border-radius:6px; font-size:12px; z-index:100; display:none; white-space:pre-wrap; }
    #restartBtn { display:none; position:fixed; top:8px; left:50%; transform:translateX(-50%); z-index:50; }
    #cheatBar { position:fixed; bottom:60px; left:50%; transform:translateX(-50%); display:none; gap:8px; z-index:90; background:#0e0e0e; padding:8px 10px; border:1px solid #2a2a2a; border-radius:6px; }
    #cheatInput { padding:8px; font-size:14px; border:1px solid #3a3a3a; background:#0b0b0b; color:#fff; }
    /* Diagnostics HUD */
    #diagHUD { position:fixed; top:8px; right:8px; z-index:120; background:#0b0b0b; border:1px solid #2a2a2a; padding:8px 10px; border-radius:8px; width:280px; font-size:12px; }
    #diagHUD h4 { margin:0 0 6px 0; color:#9ad6ad; }
    .flag { display:flex; justify-content:space-between; margin:2px 0; }
    .ok { color:#33ff66; } .bad { color:#ff6b6b; } .warn { color:#ffd166; }
    #diagLog { max-height:200px; overflow:auto; background:#0e0e0e; border:1px solid #222; padding:6px; margin-top:6px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre-wrap; }
  </style>
</head>
<body>
  <div id="topBar">
    <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
      <div id="userInfo" title="Tap while playing to open cheat bar">User: (not set)</div>
      <div id="highInfo">High: 0</div>
      <div id="netInfo"></div>
    </div>
    <div>
      <button id="backHomeBtn" class="btn" type="button" style="display:none;">⮐ Back to Home</button>
      <span id="verBadge" style="font-size:11px;opacity:.7;">build: diagnostics</span>
    </div>
  </div>

  <div id="diagHUD">
    <h4>Diagnostics</h4>
    <div class="flag"><span>Buttons wired</span><span id="f-btns" class="bad">no</span></div>
    <div class="flag"><span>Keyboard active</span><span id="f-keys" class="bad">no</span></div>
    <div class="flag"><span>Cheat bar works</span><span id="f-cheat" class="bad">no</span></div>
    <div class="flag"><span>Supabase client</span><span id="f-sb" class="warn">n/a</span></div>
    <div class="flag"><span>Owner detected</span><span id="f-owner" class="warn">n/a</span></div>
    <div id="diagLog"></div>
  </div>

  <canvas id="gameCanvas" width="400" height="600" tabindex="0" aria-label="Game canvas"></canvas>

  <div id="homeOverlay">
    <div class="retro-box">
      <div id="title" style="font-size:48px;color:#33ff66;text-shadow:0 0 8px rgba(51,255,102,.7);">DODGE THE BLOCKS</div>
      <div id="subtitle" style="margin-bottom:18px;color:#9ad6ad;">made by Ethan Fehler</div>
      <button id="playBtn" class="btn btn-accent" type="button">▶ PLAY</button>
      <div class="pressStart" style="color:#ff3dac;">PRESS PLAY TO START</div>
    </div>
    <div class="corner">
      <button id="lbBtn" class="btn" type="button">LEADERBOARD</button>
      <button id="controlsBtn" class="btn" type="button">CONTROLS</button>
      <button id="setNameBtn" class="btn" type="button">SET USERNAME</button>
    </div>
  </div>

  <!-- Cheat bar (hidden) -->
  <div id="cheatBar"><input type="password" id="cheatInput" placeholder="Enter cheat code"><button id="applyCheat" class="btn" type="button">Apply</button></div>
  <button id="restartBtn" class="btn" type="button">Restart</button>

  <!-- Leaderboard -->
  <div id="lbOverlay" class="overlay">
    <div class="modal">
      <button id="lbClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Global Leaderboard</h3>
      <table id="lbTable" style="width:100%;border-collapse:collapse;">
        <thead><tr><th>#</th><th>User</th><th>Best Score</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Name modal -->
  <div id="nameOverlay" class="overlay">
    <div class="modal">
      <button id="nameCancel" class="btn" type="button" style="float:right;">Close</button>
      <h3>Set your username</h3>
      <input id="nameInput" placeholder="e.g., PlayerOne" maxlength="20" autocomplete="off">
      <div id="nameErr" style="color:#ff6b6b;min-height:1.2em;font-size:12px;"></div>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
        <button id="nameSave" class="btn btn-accent" type="button">Save</button>
      </div>
    </div>
  </div>

  <!-- Controls modal -->
  <div id="controlsOverlay" class="overlay">
    <div class="modal">
      <button id="controlsClose" class="btn" type="button" style="float:right;">Close</button>
      <h3>Keyboard & Touch Controls</h3>
      <ul style="line-height:1.6; margin:0 0 8px 16px;">
        <li>← / → — Move left / right (desktop)</li>
        <li>Drag finger on the canvas — Move the square (mobile)</li>
        <li>P — Pause / resume (gameplay only)</li>
        <li>Enter — Confirm username</li>
        <li>Esc — Close the current dialog</li>
        <li>E — Toggle error banner</li>
      </ul>
    </div>
  </div>

  <div id="errBanner"></div>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.43.1/+esm';

    // ====== CONFIG ======
    const SUPABASE_URL = "https://staohtadlbeextexepdz.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN0YW9odGFkbGJlZXh0ZXhlcGR6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2MjAwNTIsImV4cCI6MjA3MDE5NjA1Mn0.OLQ3GIM4JV8oajuczviBsM-ueoJWV6ro65NIjpjYq0U";
    const supabase = (SUPABASE_URL && SUPABASE_ANON_KEY) ? createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;
    const OWNER_USERNAMES = new Set(["Ethan Fehler"]);
    const ALLOW_CHEATED_SCORES = true;

    // ====== DOM ======
    const $ = id => document.getElementById(id);
    const userInfo=$('userInfo'), highInfo=$('highInfo'), netInfo=$('netInfo');
    const homeOverlay=$('homeOverlay'), controlsOverlay=$('controlsOverlay');
    const lbOverlay=$('lbOverlay'), nameOverlay=$('nameOverlay');
    const nameInput=$('nameInput'), nameErr=$('nameErr');
    const canvas=$('gameCanvas'), ctx=canvas.getContext('2d');
    const restartBtn=$('restartBtn'), backHomeBtn=$('backHomeBtn');
    const cheatBar=$('cheatBar'), cheatInput=$('cheatInput'), applyCheatBtn=$('applyCheat');
    const lbTableBody = document.querySelector('#lbTable tbody');

    // ====== DIAGNOSTICS ======
    const diag = {
      logEl: $('diagLog'),
      f: {
        btns: $('f-btns'),
        keys: $('f-keys'),
        cheat: $('f-cheat'),
        sb: $('f-sb'),
        owner: $('f-owner'),
      },
      log(msg){ console.log('[DIAG]', msg); this.logEl.textContent += (this.logEl.textContent? '\n' : '') + msg; this.logEl.scrollTop = this.logEl.scrollHeight; },
      ok(el){ el.className='ok'; el.textContent='ok'; },
      bad(el){ el.className='bad'; el.textContent='no'; },
      warn(el, t='n/a'){ el.className='warn'; el.textContent=t; },
    };
    diag.warn(diag.f.sb, supabase ? 'ok' : 'n/a');

    // ====== UTIL & ERR ======
    const errEl=$('errBanner'); let errVisible=false, errText="";
    const isTypingTarget = t => t && (t.tagName==='INPUT' || t.tagName==='TEXTAREA' || t.isContentEditable);
    const showErr = (msg)=>{ errText='⚠ '+msg; errVisible=true; errEl.textContent=errText; errEl.style.display='block'; diag.log('ERR: '+msg); };
    const toggleErr = ()=>{ errVisible=!errVisible; errEl.style.display=(errVisible&&errText)?'block':'none'; };
    window.onerror = (m, s, l, c)=> showErr(`JS_ERROR: ${m} @${l}:${c}`);
    window.onunhandledrejection = (ev)=> showErr(`PROMISE_REJECTION: ${ev?.reason?.message || ev?.reason || ev}`);

    // ====== STORAGE ======
    const loadScoresLocal=()=>{ try{return JSON.parse(localStorage.getItem('dodge_scores')||'{}');}catch{return{};} };
    const saveScoresLocal=o=> localStorage.setItem('dodge_scores', JSON.stringify(o));
    const getUser=()=> (localStorage.getItem('dodge_user')||'').trim();
    const setUser=u=> localStorage.setItem('dodge_user', u);
    const updateSetNameButton=()=>{ const b=$('setNameBtn'); if(b) b.textContent=getUser()?'EDIT USERNAME':'SET USERNAME'; };

    function renderUserInfo(u){ userInfo.innerHTML='User: '+(u || '(not set)'); }

    // ====== NAME MODAL ======
    function openNameModal(prefill=""){
      nameOverlay.style.display='flex'; nameInput.value=prefill; nameErr.textContent='';
      setTimeout(()=>{ try{nameInput.focus();}catch{} },0);
      diag.log('openNameModal');
    }
    function closeNameModal(){ nameOverlay.style.display='none'; diag.log('closeNameModal'); }
    async function saveNameFromModal(){
      const u=(nameInput.value||'').trim();
      if(!u){ nameErr.textContent='Please enter a username.'; diag.log('saveNameFromModal: empty'); return; }
      setUser(u); updateSetNameButton(); renderUserInfo(u); closeNameModal(); await updateUserUI(); diag.log('saveNameFromModal: '+u);
    }

    // ====== ROLES / LEADERBOARD HELPERS ======
    let currentRole = null;
    function isOwner() {
      const u=getUser();
      return (currentRole==='owner') || (u && OWNER_USERNAMES.has(u));
    }
    async function fetchRole(username){
      if(!supabase||!username) return null;
      const { data, error } = await supabase.from('profiles').select('role').eq('username', username).maybeSingle();
      return error ? null : (data?.role||null);
    }
    async function fetchBest(username){
      if(!supabase||!username) return null;
      const { data, error } = await supabase.from('scores').select('best').eq('username', username).maybeSingle();
      return error ? null : (data?.best ?? 0);
    }

    async function updateUserUI(localOnly=false){
      const u=getUser();
      const localScores=loadScoresLocal();
      const localBest=u && localScores[u] ? localScores[u] : 0;
      if(localOnly||!supabase){
        currentRole = OWNER_USERNAMES.has(u)?'owner':null;
        userInfo.innerHTML='User: '+(u||'(not set)')+(currentRole?' <span class="role owner" style="font-size:11px;color:gold;border:1px solid #a88e00;padding:1px 6px;border-radius:10px;">owner</span>':'');
        highInfo.textContent='High: '+localBest;
        netInfo.textContent=supabase?'':'Offline leaderboard';
        diag.warn(diag.f.owner, currentRole?'owner':'n/a');
        return;
      }
      netInfo.textContent='Syncing…';
      const [rBest, rRole] = await Promise.all([fetchBest(u), fetchRole(u)]);
      currentRole = rRole || (OWNER_USERNAMES.has(u)?'owner':null);
      const best=Math.max(localBest, rBest??0);
      userInfo.innerHTML='User: '+(u||'(not set)')+(currentRole?' <span class="role '+currentRole+'" style="font-size:11px;text-transform:uppercase;">'+currentRole+'</span>':'');
      highInfo.textContent='High: '+best;
      netInfo.textContent='Online';
      diag.warn(diag.f.owner, currentRole||'n/a');
    }

    // ====== GAME ======
    const player={x:180,y:550,width:40,height:40,speed:24,color:'lime'};
    let obstacles=[], baseObstacleSpeed=4, obstacleSpeed=baseObstacleSpeed;
    let score=0, gameOver=false, baseSpawnInterval=500, spawnInterval=baseSpawnInterval;
    let spawnTimer=null, paused=true, speedIncreaseTimer=null, maxObstacleSpeed=12;
    let keys={left:false,right:false}; let screen='home', lbOpen=false;

    // Cheats state
    const cheats={ godmode:false, reverse:false, rainbow:false, ghost:false, speedy:false, bigplayer:false, tinyplayer:false, slowmo:null, slowtime:null, fastspawn:null };
    let cheatedThisRun=false;

    const controlsEnabled=()=> screen==='playing' && !lbOpen && cheatBar.style.display!=='flex';

    function spawnObstacle(){ if(!paused && !gameOver){ const w=Math.random()*60+20, x=Math.random()*(canvas.width-w); obstacles.push({x,y:cheats.reverse?(canvas.height+20):-20,width:w,height:20,color:'red'});}}
    function startSpawning(){ clearInterval(spawnTimer); spawnTimer=setInterval(spawnObstacle, spawnInterval); }
    function startSpeedIncrease(){ clearInterval(speedIncreaseTimer); speedIncreaseTimer=setInterval(()=>{ if(!paused&&!gameOver&&baseObstacleSpeed<maxObstacleSpeed){ baseObstacleSpeed+=0.5; refreshEffectiveSpeeds(); }}, 10000); }

    function refreshEffectiveSpeeds(){
      obstacleSpeed = (cheats.slowmo!=null) ? Number(cheats.slowmo) : (cheats.slowtime!=null ? Number(cheats.slowtime) : baseObstacleSpeed);
      let newSpawn=baseSpawnInterval;
      if(cheats.fastspawn!=null) newSpawn=Number(cheats.fastspawn);
      else if(cheats.slowtime!=null) newSpawn=1500;
      if(newSpawn!==spawnInterval){ spawnInterval=newSpawn; startSpawning(); }
    }

    function update(){ if(gameOver||paused||screen!=='playing') return;
      if(keys.left) player.x-=player.speed;
      if(keys.right) player.x+=player.speed;
      if(player.x<0) player.x=0;
      if(player.x+player.width>canvas.width) player.x=canvas.width-player.width;
      obstacles.forEach(o=> o.y += (cheats.reverse? -obstacleSpeed : obstacleSpeed));
      obstacles = obstacles.filter(o=> o.y<canvas.height+40 && o.y>-40);
      if(!cheats.godmode){
        for(const o of obstacles){
          if(player.x < o.x + o.width && player.x + player.width > o.x && player.y < o.y + o.height && player.y + player.height > o.y){
            onDeath(); break;
          }
        }
      }
      score += (cheats.reverse ? -1 : 1);
    }

    function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle=player.color; ctx.fillRect(player.x,player.y,player.width,player.height);
      obstacles.forEach(o=>{ ctx.fillStyle=o.color; ctx.fillRect(o.x,o.y,o.width,o.height); });
      ctx.fillStyle='white'; ctx.font='20px Arial'; ctx.fillText('Score: '+score,10,30);
      if(gameOver){ ctx.fillStyle='yellow'; ctx.font='40px Arial'; ctx.fillText('GAME OVER',80,canvas.height/2); }
      if(paused || screen!=='playing'){ ctx.fillStyle='orange'; ctx.font='30px Arial'; ctx.fillText('PAUSED',150,canvas.height/2); }
    }
    (function loop(){ update(); draw(); requestAnimationFrame(loop); })();

    function goHome(){
      screen='home'; paused=true; gameOver=false; homeOverlay.style.display='flex';
      restartBtn.style.display='none'; backHomeBtn.style.display='none';
      clearInterval(spawnTimer); clearInterval(speedIncreaseTimer); closeCheatBar();
      document.body.style.overflow='auto'; diag.log('goHome');
    }
    function startPlaying(){
      if(!getUser()){ openNameModal(''); return; }
      screen='playing'; paused=false; gameOver=false; score=0; obstacles=[]; cheatedThisRun=false;
      player.x=180; player.width=40; player.height=40; player.speed=24;
      baseObstacleSpeed=4; obstacleSpeed=baseObstacleSpeed; baseSpawnInterval=500; spawnInterval=baseSpawnInterval;
      Object.keys(cheats).forEach(c=>cheats[c]=(typeof cheats[c]==='boolean'?false:null));
      homeOverlay.style.display='none'; restartBtn.style.display='none'; backHomeBtn.style.display='inline-block';
      startSpawning(); startSpeedIncrease(); refreshEffectiveSpeeds();
      document.body.style.overflow='hidden'; canvas.focus(); diag.log('startPlaying');
    }

    function saveBestLocal(u,s){ const scores=loadScoresLocal(); const prev=scores[u]||0; if(s>prev){ scores[u]=s; saveScoresLocal(scores);} }

    function onDeath(){
      if(gameOver) return;
      gameOver=true; clearInterval(spawnTimer); clearInterval(speedIncreaseTimer);
      restartBtn.style.display='inline-block'; showErr('E_DEAD: Hit a block — press Restart'); diag.log('onDeath');
    }

    // ====== Leaderboard ======
    async function openLeaderboard(){
      lbOverlay.style.display='flex'; lbOpen=true; diag.log('openLeaderboard');
    }
    function closeLeaderboard(){ lbOverlay.style.display='none'; lbOpen=false; diag.log('closeLeaderboard'); }

    // ====== Cheats (basic for diagnostics) ======
    function showCheatBar(){ if(screen!=='playing') return; paused=true; cheatBar.style.display='flex'; setTimeout(()=>{ cheatInput.focus(); },0); diag.ok(diag.f.cheat); diag.log('showCheatBar'); }
    function closeCheatBar(){ cheatBar.style.display='none'; cheatInput.value=''; if(screen==='playing'&&!gameOver) paused=false; diag.log('closeCheatBar'); }
    function applyCheat(){ const raw=(cheatInput.value||'').trim(); diag.log('applyCheat: '+raw); closeCheatBar(); }

    // ====== INPUT BINDINGS ======
    function handle(id){
      diag.log('click:'+id);
      switch(id){
        case 'playBtn': startPlaying(); break;
        case 'restartBtn': if(screen==='playing'){ startPlaying(); } break;
        case 'backHomeBtn': goHome(); break;
        case 'lbBtn': openLeaderboard(); break;
        case 'lbClose': closeLeaderboard(); break;
        case 'setNameBtn': openNameModal(getUser()); break;
        case 'nameSave': saveNameFromModal(); break;
        case 'nameCancel': closeNameModal(); break;
        case 'controlsBtn': controlsOverlay.style.display='flex'; break;
        case 'controlsClose': controlsOverlay.style.display='none'; break;
        case 'applyCheat': applyCheat(); break;
      }
    }
    ['playBtn','restartBtn','backHomeBtn','lbBtn','lbClose','setNameBtn','nameSave','nameCancel','controlsBtn','controlsClose','applyCheat']
      .forEach(id=>{ const el=$(id); if(el){ el.addEventListener('click', ()=>handle(id)); }});
    diag.ok(diag.f.btns);

    function usernameTap(e){ if(screen==='playing'){ e.preventDefault(); showCheatBar(); } else { openNameModal(getUser()); } }
    userInfo.addEventListener('click', usernameTap);
    userInfo.addEventListener('touchstart', (e)=>{ e.preventDefault(); usernameTap(e); }, {passive:false});

    // Drag controls
    let dragging=false;
    const canvasX = (clientX)=>{ const r=canvas.getBoundingClientRect(); const x=(clientX-r.left)*(canvas.width/r.width); return Math.max(0, Math.min(canvas.width-player.width, x-player.width/2)); };
    canvas.addEventListener('mousedown', e=>{ if(screen!=='playing') return; e.preventDefault(); dragging=true; player.x=canvasX(e.clientX); });
    window.addEventListener('mousemove', e=>{ if(dragging && screen==='playing'){ e.preventDefault(); player.x=canvasX(e.clientX); } });
    window.addEventListener('mouseup', ()=>{ dragging=false; });
    canvas.addEventListener('touchstart', e=>{ if(screen!=='playing') return; if(e.touches[0]){ e.preventDefault(); dragging=true; player.x=canvasX(e.touches[0].clientX);} }, {passive:false});
    canvas.addEventListener('touchmove', e=>{ if(dragging && e.touches[0]){ e.preventDefault(); player.x=canvasX(e.touches[0].clientX);} }, {passive:false});
    canvas.addEventListener('touchend', e=>{ e.preventDefault(); dragging=false; }, {passive:false});
    canvas.addEventListener('touchcancel', e=>{ e.preventDefault(); dragging=false; }, {passive:false});

    // Keyboard
    window.addEventListener('keydown', (e)=>{
      const typing = isTypingTarget(e.target) || (cheatBar.style.display==='flex');
      if((e.key==='e'||e.key==='E') && !isTypingTarget(e.target)){ e.preventDefault(); toggleErr(); diag.log('toggleErr'); }
      if(screen==='playing' && !lbOpen && !typing){
        if(e.key==='ArrowLeft' || e.key==='Left' || e.keyCode===37){ e.preventDefault(); keys.left=true; diag.ok(diag.f.keys); diag.log('key:left'); }
        if(e.key==='ArrowRight' || e.key==='Right' || e.keyCode===39){ e.preventDefault(); keys.right=true; diag.ok(diag.f.keys); diag.log('key:right'); }
        if(e.key==='p' || e.key==='P' || e.keyCode===80){ e.preventDefault(); paused=!paused; diag.log('key:p pause='+paused); }
      }
      if(e.key==='Shift' && screen==='playing' && cheatBar.style.display!=='flex'){ e.preventDefault(); showCheatBar(); }
      if(cheatBar.style.display==='flex'){
        if(e.key==='Enter'){ e.preventDefault(); applyCheat(); }
        if(e.key==='Escape'){ e.preventDefault(); closeCheatBar(); }
      }
      if(nameOverlay.style.display==='flex'){
        if(e.key==='Enter'){ e.preventDefault(); saveNameFromModal(); }
        if(e.key==='Escape'){ e.preventDefault(); closeNameModal(); }
      }
    });
    window.addEventListener('keyup', (e)=>{
      if(screen==='playing' && !lbOpen && !(isTypingTarget(e.target))){
        if(e.key==='ArrowLeft' || e.key==='Left' || e.keyCode===37){ e.preventDefault(); keys.left=false; }
        if(e.key==='ArrowRight' || e.key==='Right' || e.keyCode===39){ e.preventDefault(); keys.right=false; }
      }
    });

    // Init
    updateSetNameButton();
    await updateUserUI();
    goHome();
  </script>
</body>
</html>
