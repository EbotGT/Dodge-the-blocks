<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Dodge the Blocks — Cheats Count on Leaderboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    :root { --green:#33ff66; --accent:#ff3dac; --scanline:rgba(255,255,255,0.06); }
    html, body { height: 100%; }
    body { margin: 0; background:#1a1a1a; display:flex; justify-content:center; align-items:center; color:#eee; font-family:"Courier New", monospace; }
    canvas { background:#0b0b0b; display:block; border:2px solid #2a2a2a; box-shadow:0 0 24px rgba(0,0,0,.6) inset; z-index:1; pointer-events:auto; touch-action: none; }

    button, .btn { pointer-events:auto; touch-action: manipulation; position:relative; z-index:50; }
    .btn { font-family:inherit; font-weight:bold; padding:12px 22px; font-size:18px; cursor:pointer; margin:6px; border:2px solid var(--green); background:transparent; color:var(--green); text-shadow:0 0 6px rgba(51,255,102,.5); }
    .btn:hover { background: rgba(51,255,102,.1); }
    .btn-accent { border-color: var(--accent); color: var(--accent); text-shadow: 0 0 6px rgba(255,61,172,.6); }

    #topBar { position:fixed; top:8px; left:8px; right:8px; display:flex; gap:8px; align-items:center; justify-content:space-between; z-index:40; font-size:14px; pointer-events:auto; }
    #userInfo, #highInfo, #netInfo { opacity:.9; }
    #userInfo { cursor:pointer; }
    #userInfo .role { margin-left:6px; padding:1px 6px; border:1px solid #777; border-radius:10px; font-size:11px; text-transform:uppercase; }
    #userInfo .role.owner { color:gold; border-color:#a88e00; }
    #userInfo .role.creator { color:#9ad6ff; border-color:#0077cc; }
    #verBadge { position:fixed; bottom:8px; right:8px; font-size:11px; opacity:.7; background:#0e0e0e; border:1px solid #333; padding:4px 6px; border-radius:4px; z-index:120; }

    #homeOverlay { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: repeating-linear-gradient(0deg,transparent 0px, transparent 2px, var(--scanline) 3px, transparent 4px), radial-gradient(circle at 50% 20%, rgba(255,61,172,.12), transparent 40%), #050505;
      text-align:center; overflow:hidden; z-index:30; pointer-events:auto; }
    .retro-box { border:3px solid var(--green); box-shadow:0 0 24px rgba(51,255,102,.25), inset 0 0 12px rgba(51,255,102,.1); padding:22px 28px; background:#0c0c0c; pointer-events:auto; position:relative; z-index:60; }
    #title { font-size:48px; letter-spacing:2px; margin:0 0 8px 0; color:#33ff66; text-shadow:0 0 8px rgba(51,255,102,.7), 0 0 2px rgba(51,255,102,.7); }
    #subtitle { margin-bottom:18px; color:#9ad6ad; font-size:16px; text-shadow: 0 0 4px rgba(154,214,173,0.6); }
    .pressStart { margin-top:8px; font-size:16px; color:var(--accent); text-shadow: 0 0 8px rgba(255,61,172,.6); }
    .corner { position:absolute; top:16px; right:16px; display:flex; flex-wrap:wrap; gap:8px; pointer-events:auto; z-index:80; }

    /* Modals */
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,.8); display:none; align-items:center; justify-content:center; z-index:70; pointer-events:auto; }
    .modal { width:560px; max-width:92vw; max-height:75vh; overflow:auto; background:#121212; border:2px solid var(--green); box-shadow:0 0 20px rgba(51,255,102,.3); border-radius:8px; padding:16px; position:relative; z-index:85; }
    .modal h3 { margin:0 0 8px 0; }
    .modal .close { float:right; margin-top:-8px; }

    #lbTable { width:100%; border-collapse:collapse; }
    #lbTable th, #lbTable td { border:1px solid #666; padding:6px 8px; }
    #lbTable .role { font-size:11px; margin-left:6px; text-transform:uppercase; opacity:.9; }

    #nameInput { width:100%; padding:10px; font-size:16px; background:#0e0e0e; color:#fff; border:1px solid #3a3a3a; box-sizing:border-box; }
    #nameErr { color:#ff6b6b; min-height:1.2em; font-size:12px; }

    #errBanner { position:fixed; bottom:8px; left:8px; right:8px; background:#0e1010; color:#e3ffee; padding:8px 10px; border:1px solid #2dd562; border-radius:6px; font-size:12px; z-index:100; display:none; white-space:pre-wrap; }
    /* Restart hidden by default */
    #restartBtn { display:none; position:fixed; top:8px; left:50%; transform:translateX(-50%); z-index:50; }

    /* Cheat bar */
    #cheatBar {
      position:fixed; bottom:60px; left:50%; transform:translateX(-50%);
      display:none; gap:8px; z-index:90;
      background:#0e0e0e; padding:8px 10px; border:1px solid #2a2a2a; border-radius:6px;
    }
    #cheatInput { padding:8px; font-size:14px; border:1px solid #3a3a3a; background:#0b0b0b; color:#fff; }
    #cheatHint { position:fixed; bottom:98px; left:50%; transform:translateX(-50%); font-size:12px; opacity:.8; display:none; }
    #cheatHint small code { background:#111; border:1px solid #333; padding:1px 4px; }
  </style>
</head>
<body>
  <div id="topBar">
    <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
      <div id="userInfo" title="Tap while playing to open cheat bar">User: (not set)</div>
      <div id="highInfo">High: 0</div>
      <div id="netInfo"></div>
    </div>
    <div>
      <button id="backHomeBtn" class="btn" type="button" style="display:none;">⮐ Back to Home</button>
      <span id="verBadge">build: cheats-count-leaderboard</span>
    </div>
  </div>

  <canvas id="gameCanvas" width="400" height="600" aria-label="Game canvas"></canvas>

  <div id="homeOverlay" aria-label="Home screen">
    <div class="retro-box">
      <div id="title">DODGE THE BLOCKS</div>
      <div id="subtitle">made by Ethan Fehler</div>
      <button id="playBtn" class="btn btn-accent" type="button">▶ PLAY</button>
      <div class="pressStart">PRESS PLAY TO START</div>
    </div>
    <div class="corner">
      <button id="lbBtn" class="btn" type="button">LEADERBOARD</button>
      <button id="controlsBtn" class="btn" type="button">CONTROLS</button>
      <button id="setNameBtn" class="btn" type="button">SET USERNAME</button>
    </div>
  </div>

  <!-- Cheat bar -->
  <div id="cheatBar" role="group" aria-label="Cheat input">
    <input type="password" id="cheatInput" placeholder="Enter cheat code">
    <button id="applyCheat" class="btn" type="button">Apply</button>
  </div>
  <div id="cheatHint"><small>Try <code>godmode</code>, <code>speedy</code>, <code>reverse</code>, <code>points1000</code>, <code>slowmo2</code>, <code>fastspawn200</code>, <code>disable speedy</code></small></div>

  <button id="restartBtn" class="btn" type="button">Restart</button>

  <!-- Leaderboard -->
  <div id="lbOverlay" class="overlay" aria-modal="true">
    <div class="modal">
      <button id="lbClose" class="btn close" type="button">Close</button>
      <h3>Global Leaderboard</h3>
      <table id="lbTable">
        <thead><tr><th>#</th><th>User</th><th>Best Score</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Name modal -->
  <div id="nameOverlay" class="overlay" aria-modal="true">
    <div class="modal">
      <button id="nameCancel" class="btn close" type="button">Close</button>
      <h3>Set your username</h3>
      <input id="nameInput" placeholder="e.g., PlayerOne" maxlength="20" autocomplete="off">
      <div id="nameErr"></div>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
        <button id="nameSave" class="btn btn-accent" type="button">Save</button>
      </div>
    </div>
  </div>

  <!-- Controls modal -->
  <div id="controlsOverlay" class="overlay" aria-modal="true">
    <div class="modal">
      <button id="controlsClose" class="btn close" type="button">Close</button>
      <h3>Keyboard & Touch Controls</h3>
      <ul style="line-height:1.6; margin:0 0 8px 16px;">
        <li>← / → — Move left / right (desktop)</li>
        <li>Drag finger on the canvas — Move the square (mobile)</li>
        <li>P — Pause / resume (gameplay only)</li>
        <li>Enter — Confirm username</li>
        <li>Esc — Close the current dialog</li>
        <li>E — Toggle error banner</li>
        <li>Shift — Open cheat bar (game pauses while open)</li>
        <li><b>Tap your username</b> (top-left) while playing — open cheat bar</li>
      </ul>
    </div>
  </div>

  <div id="errBanner"></div>

  <script type="module">
  import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.43.1/+esm';

  // === Paste your Supabase credentials here ===
  const SUPABASE_URL = "https://staohtadlbeextexepdz.supabase.co"; // <-- your project URL
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN0YW9odGFkbGJlZXh0ZXhlcGR6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ2MjAwNTIsImV4cCI6MjA3MDE5NjA1Mn0.OLQ3GIM4JV8oajuczviBsM-ueoJWV6ro65NIjpjYq0U"; // <-- your anon key
  const supabase = (SUPABASE_URL.startsWith('http') && SUPABASE_ANON_KEY && SUPABASE_ANON_KEY.length>20) ? createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;

  // Optional: force-show owner tag for these usernames (client-side fallback)
  const OWNER_USERNAMES = new Set(["Ethan Fehler"]);

  // NEW: Allow submitting scores even if cheats were used
  const ALLOW_CHEATED_SCORES = true;

  // ===== Error banner: auto-show on errors + toggle with E (but not while typing) =====
  const errEl = document.getElementById('errBanner'); let errVisible=false; let errText="";
  const isTypingTarget = t => t && (t.tagName==='INPUT' || t.tagName==='TEXTAREA' || t.isContentEditable);
  const errRender = () => { errEl.style.display = (errVisible && errText) ? 'block' : 'none'; errEl.textContent = errText; };
  const errShow = msg => { errText = '⚠ ' + msg; errVisible = true; errRender(); console.log('[ERR]', msg); };
  const errToggle = () => { errVisible = !errVisible; errRender(); };
  document.addEventListener('keydown', e => { if((e.key==='e'||e.key==='E') && !isTypingTarget(e.target)){ e.preventDefault(); errToggle(); }}, true);
  window.onerror = (message, source, lineno, colno) => errShow(`JS_ERROR: ${message} @${lineno}:${colno}`);
  window.onunhandledrejection = ev => errShow(`PROMISE_REJECTION: ${ev?.reason?.message || ev?.reason || ev}`);

  // ===== Helpers =====
  const $ = id => document.getElementById(id);
  const userInfo=$('userInfo'), highInfo=$('highInfo'), netInfo=$('netInfo');
  const homeOverlay=$('homeOverlay');
  const lbOverlay=$('lbOverlay'), nameOverlay=$('nameOverlay'), controlsOverlay=$('controlsOverlay');
  const nameInput=$('nameInput'), nameErr=$('nameErr');
  const canvas=$('gameCanvas'), ctx=canvas.getContext('2d');
  const restartBtn=$('restartBtn'), backHomeBtn=$('backHomeBtn');
  const cheatBar=$('cheatBar'), cheatInput=$('cheatInput'), cheatHint=$('cheatHint');
  const lbTableBody = document.querySelector('#lbTable tbody');

  const loadScoresLocal=()=>{ try{return JSON.parse(localStorage.getItem('dodge_scores')||'{}');}catch{ return{}; } };
  const saveScoresLocal=o=> localStorage.setItem('dodge_scores',JSON.stringify(o));
  const getUser=()=> (localStorage.getItem('dodge_user')||'').trim();
  const setUser=u=> localStorage.setItem('dodge_user',u);
  const updateSetNameButton=()=> { const el=$('setNameBtn'); if(el) el.textContent=getUser()?'EDIT USERNAME':'SET USERNAME'; };

  function roleBadge(role, username){
    if(role) return `<span class="role ${role}">${role}</span>`;
    if(OWNER_USERNAMES.has(username)) return `<span class="role owner">owner</span>`;
    return '';
  }

  async function fetchRole(username){
    if(!supabase || !username) return null;
    try{
      const { data, error } = await supabase.from('profiles').select('role').eq('username', username).maybeSingle();
      if(error) return null;
      return data?.role || null;
    }catch{ return null; }
  }

  async function fetchBest(username){
    if(!supabase || !username) return null;
    try{
      const { data, error } = await supabase.from('scores').select('best').eq('username', username).maybeSingle();
      if(error) return null;
      return data?.best ?? 0;
    }catch{ return null; }
  }

  async function updateUserUI(localOnly=false){
    const u=getUser();
    const localScores = loadScoresLocal();
    const localBest = u && localScores[u] ? localScores[u] : 0;
    let role=null;
    if(localOnly || !supabase){
      userInfo.innerHTML = 'User: ' + (u || '(not set)') + (roleBadge(null, u));
      highInfo.textContent = 'High: ' + localBest;
      netInfo.textContent = supabase ? '' : 'Offline leaderboard';
      return;
    }
    netInfo.textContent='Syncing…';
    const [rBest, rRole] = await Promise.all([fetchBest(u), fetchRole(u)]);
    role = rRole;
    const best = Math.max(localBest, rBest ?? 0);
    userInfo.innerHTML = 'User: ' + (u || '(not set)') + (roleBadge(role, u));
    highInfo.textContent = 'High: ' + best;
    netInfo.textContent='Online';
  }

  // ===== Game =====
  const player={x:180,y:550,width:40,height:40,speed:24,color:'lime'};
  let obstacles=[], baseObstacleSpeed=4, obstacleSpeed=baseObstacleSpeed;
  let score=0, gameOver=false, baseSpawnInterval=500, spawnInterval=baseSpawnInterval;
  let spawnTimer=null, paused=true, speedIncreaseTimer=null, maxObstacleSpeed=12;
  let keys={left:false,right:false}; let screen='home', lbOpen=false;

  // Cheats
  const cheats = { godmode:false, reverse:false, rainbow:false, ghost:false, speedy:false, bigplayer:false, tinyplayer:false, table:false, slowmo:null, slowtime:null, fastspawn:null };
  let cheatedThisRun = false;
  const cheatColors = { godmode:"gold", reverse:"red", rainbow:null, ghost:"gray", speedy:"cyan", bigplayer:"orange", tinyplayer:"pink", table:"khaki", slowmo:"lightblue", slowtime:"lightgreen", fastspawn:"violet" };

  const controlsEnabled=()=> screen==='playing'&&!lbOpen&&cheatBar.style.display!=='flex';

  function spawnObstacle(){ if(!paused&&!gameOver){ const w=Math.random()*60+20, x=Math.random()*(canvas.width-w); obstacles.push({x:x,y: cheats.reverse? (canvas.height+20) : -20,width:w,height:20,color:'red'});}}
  function startSpawning(){ clearInterval(spawnTimer); spawnTimer=setInterval(spawnObstacle,spawnInterval); }
  function startSpeedIncrease(){ clearInterval(speedIncreaseTimer); speedIncreaseTimer=setInterval(()=>{ if(!paused&&!gameOver&&baseObstacleSpeed<maxObstacleSpeed){ baseObstacleSpeed+=0.5; refreshEffectiveSpeeds(); }},10000); }

  function refreshEffectiveSpeeds(){
    if (cheats.slowmo != null) obstacleSpeed = Number(cheats.slowmo);
    else if (cheats.slowtime != null) obstacleSpeed = Number(cheats.slowtime);
    else obstacleSpeed = baseObstacleSpeed;

    let newSpawn = baseSpawnInterval;
    if (cheats.fastspawn != null) newSpawn = Number(cheats.fastspawn);
    else if (cheats.slowtime != null) newSpawn = 1500;

    if (newSpawn !== spawnInterval){ spawnInterval = newSpawn; startSpawning(); }
  }

  function update(){ if(gameOver||paused||screen!=='playing') return;
    if(keys.left) player.x-=player.speed;
    if(keys.right) player.x+=player.speed;
    if(player.x<0) player.x=0;
    if(player.x+player.width>canvas.width) player.x=canvas.width-player.width;
    obstacles.forEach(o=> o.y += (cheats.reverse? -obstacleSpeed : obstacleSpeed));
    obstacles = obstacles.filter(o=> o.y<canvas.height+40 && o.y>-40);
    if(!cheats.godmode){
      obstacles.forEach(o=>{
        if(player.x < o.x + o.width && player.x + player.width > o.x && player.y < o.y + o.height && player.y + player.height > o.y){
          onDeath();
        }
      });
    }
    score += (cheats.reverse ? -1 : 1);
    if(cheats.rainbow){
      player.color = `hsl(${(Date.now()/10)%360},100%,50%)`;
      obstacles.forEach((o,i)=> o.color = `hsl(${(Date.now()/10 + i*20)%360},100%,50%)`);
    } else {
      player.color = cheats.ghost ? 'rgba(0,0,0,0)' : 'lime';
    }
  }

  function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle=player.color; ctx.fillRect(player.x,player.y,player.width,player.height);
    obstacles.forEach(o=>{ ctx.fillStyle=o.color; ctx.fillRect(o.x,o.y,o.width,o.height); });
    ctx.fillStyle='white'; ctx.font='20px Arial'; ctx.fillText('Score: '+score,10,30);

    // Active cheats list
    const active = Object.keys(cheats).filter(c => cheats[c] || cheats[c]===0);
    if(active.length){
      ctx.font='14px Arial';
      active.forEach((c,i)=>{
        ctx.fillStyle = (c==='rainbow') ? `hsl(${(Date.now()/10)%360},100%,50%)` : (cheatColors[c] || 'white');
        const val = (typeof cheats[c] === 'number') ? `(${cheats[c]})` : '';
        ctx.fillText(c+val, canvas.width-150, 20 + i*16);
      });
    }

    if(gameOver){ ctx.fillStyle='yellow'; ctx.font='40px Arial'; ctx.fillText('GAME OVER',80,canvas.height/2); }
    if(paused || screen!=='playing'){ ctx.fillStyle='orange'; ctx.font='30px Arial'; ctx.fillText('PAUSED',150,canvas.height/2); }
  }
  (function loop(){ update(); draw(); requestAnimationFrame(loop); })();

  function goHome(){ screen='home'; paused=true; gameOver=false; homeOverlay.style.display='flex'; restartBtn.style.display='none'; backHomeBtn.style.display='none'; clearInterval(spawnTimer); clearInterval(speedIncreaseTimer); closeCheatBar(); }
  function startPlaying(){ if(!getUser()){ openNameModal(''); return; } screen='playing'; paused=false; gameOver=false; score=0; obstacles=[]; cheatedThisRun=false;
    player.x=180; player.width=40; player.height=40; player.speed=24;
    baseObstacleSpeed=4; obstacleSpeed=baseObstacleSpeed; baseSpawnInterval=500; spawnInterval=baseSpawnInterval;
    Object.keys(cheats).forEach(c=>cheats[c]=(typeof cheats[c]==='boolean'?false:null));
    homeOverlay.style.display='none'; restartBtn.style.display='none'; backHomeBtn.style.display='inline-block';
    startSpawning(); startSpeedIncrease(); refreshEffectiveSpeeds();
  }

  function saveBestLocal(u, s){ const scores = loadScoresLocal(); const prev = scores[u] || 0; if(s > prev){ scores[u]=s; saveScoresLocal(scores);} }

  async function submitScore(u, s){
    saveBestLocal(u, s);
    if(!supabase) { await updateUserUI(true); return; }
    try{
      const currentBest = await fetchBest(u) ?? 0;
      const newBest = Math.max(currentBest, s);
      const { error } = await supabase.from('scores').upsert({ username: u, best: newBest }).select('best').maybeSingle();
      if(error){ errShow('E_DB_WRITE: Score submit failed — '+error.message); await updateUserUI(); return; }
      await updateUserUI();
    }catch(e){
      errShow('E_NET: Network error submitting score');
    }
  }

  function onDeath(){
    if(gameOver) return;
    gameOver=true; clearInterval(spawnTimer); clearInterval(speedIncreaseTimer);
    const u=getUser();
    if (u && (ALLOW_CHEATED_SCORES || !cheatedThisRun)) {
      submitScore(u, score);
    }
    restartBtn.style.display='inline-block'; errShow('E_DEAD: Hit a block — press Restart to play again.');
  }

  // Leaderboard
  async function openLeaderboard(){
    lbOpen=true; lbOverlay.style.display='flex';
    lbTableBody.innerHTML='<tr><td colspan="3" style="text-align:center;opacity:.8;">Loading…</td></tr>';
    if(!supabase){
      const scores = loadScoresLocal();
      const rows = Object.keys(scores).map(user=>({username:user,best:scores[user]})).sort((a,b)=>b.best-a.best).slice(0,50);
      lbTableBody.innerHTML = rows.length ? rows.map((r,i)=>`<tr><td>${i+1}</td><td>${r.username}${roleBadge(null, r.username)}</td><td>${r.best}</td></tr>`).join('') : '<tr><td colspan="3" style="text-align:center;opacity:.8;">No scores yet</td></tr>';
      return;
    }
    try{
      const [{ data, error }, rolesRes] = await Promise.all([
        supabase.from('scores').select('username,best').order('best', { ascending:false }).limit(50),
        supabase.from('profiles').select('username,role')
      ]);
      if(error){ lbTableBody.innerHTML = `<tr><td colspan="3" style="text-align:center;opacity:.8;">Load error: ${error.message}</td></tr>`; return; }
      const roleMap = new Map();
      if(!rolesRes.error && rolesRes.data){ rolesRes.data.forEach(r=> roleMap.set(r.username, r.role)); }
      lbTableBody.innerHTML = (data||[]).map((r,i)=>{
        const role = roleMap.get(r.username) || (OWNER_USERNAMES.has(r.username) ? 'owner' : null);
        return `<tr><td>${i+1}</td><td>${r.username}${role ? `<span class="role ${role}">${role}</span>`:''}</td><td>${r.best}</td></tr>`;
      }).join('') || '<tr><td colspan="3" style="text-align:center;opacity:.8;">No scores yet</td></tr>';
    }catch(e){
      lbTableBody.innerHTML = `<tr><td colspan="3" style="text-align:center;opacity:.8;">Network error</td></tr>`;
    }
  }
  function closeLeaderboard(){ lbOverlay.style.display='none'; lbOpen=false; }

  // ===== Touch & Mouse drag controls on canvas =====
  let dragging=false;
  const canvasXFromEvent = clientX => {
    const rect=canvas.getBoundingClientRect(); const x=(clientX-rect.left)*(canvas.width/rect.width);
    return Math.max(0, Math.min(canvas.width - player.width, x - player.width/2));
  };
  const beginDrag = clientX => { if(screen!=='playing') return; dragging=true; player.x = canvasXFromEvent(clientX); };
  const moveDrag  = clientX => { if(!dragging || screen!=='playing') return; player.x = canvasXFromEvent(clientX); };
  const endDrag   = () => { dragging=false; };
  // Mouse
  canvas.addEventListener('mousedown', e=>{ e.preventDefault(); beginDrag(e.clientX); });
  window.addEventListener('mousemove', e=>{ if(dragging){ e.preventDefault(); moveDrag(e.clientX); } });
  window.addEventListener('mouseup', ()=>{ endDrag(); });
  // Touch
  canvas.addEventListener('touchstart', e=>{ if(e.touches && e.touches[0]){ e.preventDefault(); beginDrag(e.touches[0].clientX); } }, {passive:false});
  canvas.addEventListener('touchmove',  e=>{ if(e.touches && e.touches[0]){ e.preventDefault(); moveDrag(e.touches[0].clientX); } }, {passive:false});
  canvas.addEventListener('touchend',   e=>{ e.preventDefault(); endDrag(); }, {passive:false});
  canvas.addEventListener('touchcancel',e=>{ e.preventDefault(); endDrag(); }, {passive:false});

  // ===== Cheat bar logic =====
  function showCheatBar(){ if(screen!=='playing') return; paused=true; cheatBar.style.display='flex'; cheatHint.style.display='block'; setTimeout(()=>{ cheatInput.focus(); },0); }
  function closeCheatBar(){ cheatBar.style.display='none'; cheatInput.value=''; cheatHint.style.display='none'; if(screen==='playing' && !gameOver) paused=false; }
  function refreshEffectiveAndClose(){ refreshEffectiveSpeeds(); closeCheatBar(); }

  function applyCheat(){
    const raw=(cheatInput.value||'').trim().toLowerCase();
    if(!raw){ closeCheatBar(); return; }
    const isCheatThatMatters = !raw.startsWith('disable ') && !raw.startsWith('clear') && !raw.startsWith('table');
    if(isCheatThatMatters) cheatedThisRun = true;

    if(raw.startsWith('disable ')){
      const d=raw.slice(8).trim();
      if(d in cheats){
        if(typeof cheats[d]==='boolean'){
          cheats[d]=false;
          if(d==='bigplayer'||d==='tinyplayer'){ player.width=40; player.height=40; }
          if(d==='speedy') player.speed=24;
        } else { cheats[d]=null; }
        return refreshEffectiveAndClose();
      } else {
        return closeCheatBar();
      }
    }

    const m=raw.match(/^([a-z]+)(\d+)?$/);
    if(!m){ closeCheatBar(); return; }
    const base=m[1], num=m[2]?parseInt(m[2],10):null;

    if(base in cheats && typeof cheats[base]==='boolean'){
      cheats[base]=true;
      if(base==='speedy') player.speed=35;
      if(base==='bigplayer'){ player.width=80; player.height=80; }
      if(base==='tinyplayer'){ player.width=20; player.height=20; }
      if(base==='table'){ /* UI hint only */ }
    } else if(base==='points'){
      score += (num!=null?num:1000);
    } else if(base==='slowmo'){
      cheats.slowmo = (num!=null?num:1);
    } else if(base==='slowtime'){
      cheats.slowtime = (num!=null?num:1);
    } else if(base==='fastspawn'){
      cheats.fastspawn = (num!=null?num:200);
    } else if(base==='clear'){
      obstacles = [];
    }
    refreshEffectiveAndClose();
  }

  // ===== Button & tap actions =====
  function handle(id){
    switch(id){
      case 'playBtn': startPlaying(); break;
      case 'restartBtn': if(screen==='playing'){ startPlaying(); } break;
      case 'backHomeBtn': goHome(); break;
      case 'lbBtn': openLeaderboard(); break;
      case 'lbClose': closeLeaderboard(); break;
      case 'setNameBtn': openNameModal(getUser()); break;
      case 'nameSave': saveNameFromModal(); break;
      case 'nameCancel': closeNameModal(); break;
      case 'controlsBtn': controlsOverlay.style.display='flex'; break;
      case 'controlsClose': controlsOverlay.style.display='none'; break;
      case 'applyCheat': applyCheat(); break;
    }
  }
  // Direct listeners
  ['playBtn','restartBtn','backHomeBtn','lbBtn','lbClose','setNameBtn','nameSave','nameCancel','controlsBtn','controlsClose','applyCheat'].forEach(id=>{ const el=$(id); if(el){ el.addEventListener('click', ()=> handle(id)); }});
  // Delegation + capture + touch
  document.addEventListener('click', e=>{ const t=e.target; const id = (t.tagName==='BUTTON') ? t.id : (t.closest && t.closest('button') ? t.closest('button').id : null); if(id) handle(id); });
  window.addEventListener('click', e=>{ const t=e.target; const id = (t.tagName==='BUTTON') ? t.id : (t.closest && t.closest('button') ? t.closest('button').id : null); if(id) handle(id); }, true);
  window.addEventListener('touchstart', e=>{ const t=e.target; const id = (t.tagName==='BUTTON') ? t.id : (t.closest && t.closest('button') ? t.closest('button') : null); if(id && id.id){ e.preventDefault(); handle(id.id); } }, {passive:false});

  // Keyboard
  document.addEventListener('keydown', e=>{
    if(e.key==='Shift' && screen==='playing' && cheatBar.style.display!=='flex'){ e.preventDefault(); showCheatBar(); return; }
    if(controlsEnabled() && !isTypingTarget(e.target)){
      if(e.key==='ArrowLeft') keys.left=true;
      if(e.key==='ArrowRight') keys.right=true;
      if(e.key && e.key.toLowerCase()==='p') paused=!paused;
    }
    if(cheatBar.style.display==='flex'){
      if(e.key==='Enter'){ e.preventDefault(); applyCheat(); }
      if(e.key==='Escape'){ e.preventDefault(); closeCheatBar(); }
    }
    if(nameOverlay.style.display==='flex'){
      if(e.key==='Enter'){ e.preventDefault(); saveNameFromModal(); }
      if(e.key==='Escape'){ e.preventDefault(); closeNameModal(); }
    }
  });
  document.addEventListener('keyup', e=>{
    if(controlsEnabled()){
      if(e.key==='ArrowLeft') keys.left=false;
      if(e.key==='ArrowRight') keys.right=false;
    }
  });

  // Name modal helpers
  function openNameModal(prefill){ nameOverlay.style.display='flex'; nameInput.value=prefill||''; nameErr.textContent=''; setTimeout(()=>{ try{nameInput.focus();}catch{} } ,0); }
  function closeNameModal(){ nameOverlay.style.display='none'; }
  async function saveNameFromModal(){ const u=(nameInput.value||'').trim(); if(!u){ nameErr.textContent='Please enter a username.'; return; } setUser(u); updateSetNameButton(); renderUserInfo(u); closeNameModal(); await updateUserUI(); }
  function renderUserInfo(u){ userInfo.innerHTML='User: '+(u||'(not set)'); } // role appended in updateUserUI

  // Username tap: open cheat bar during play; on home, edit name
  function usernameCheatTrigger(e){
    if(screen==='playing'){
      e.preventDefault();
      showCheatBar();
    } else if(screen==='home'){
      openNameModal(getUser());
    }
  }
  userInfo.addEventListener('click', usernameCheatTrigger);
  userInfo.addEventListener('touchstart', function(e){ e.preventDefault(); usernameCheatTrigger(e); }, {passive:false});

  // Init
  await updateUserUI();
  goHome();
  </script>
</body>
</html>
